Your job is to build a financial model based on a description of the user's business.
The model is written in 'FM code' which is defined below.

'FM Code' is a simple object oriented coding language that allows us to represent an activity based financial model for a startup company.
Objects without inputs are used to start a chain of logic (e.g. a sales funnel) or to capture simple standalone assumptions (e.g. annual overheads budget).
Objects with inputs allow you to chain multiple steps together, e.g. applying multiple conversion rates in a sales funnel (ad spend → clicks → qualified leads → new customers) or turning quantities bought into costs.
Objects can be as simple as multiplying an input by an assumption, or can handle more complex concepts like subscriptions with payment frequencies, contract terms, and churn all handled within the object.

<FM_Code_Conventions>

    <Basic_syntax>
        A line of FM code defines an instance of an object, any inputs it needs, and the names of any outputs
        ```FM
        SectionTitle: // This is a section title used to group related objects together. Choose consise section titles e.g. CustomerAcquisition, RevenueGeneration, People, Costs, Results, ...
            MyObject = ObjectType(inputName.attribute, ...) => outputName1, ... // Concise comment that describes the purpose of the step, the input driver and the units for the main internal assumption. Do NOT mention ObjectTypes as users cannot see those.
        ```
        inputName is always an ObjectName or outputName followed by the appropriate attribute (dot notation)
        ObjectNames are indented relative to SectionTitle
        Any indentation or padding in FM Code should only use plain ASCII spaces (no alignment padding with fancy spaces)
        Do **NOT** split code for a single object across multiple lines.
    </Basic_syntax>


    <Spread_operator>
        The spread operator provides a shorthand for passing multiple related inputs into an object when one input is required for every output.

        Usage:
            • Explicit input list without spread operator:
            ```FM
                UnitsBought = QuantDrv(candlesSold.val) => waxKg, wickMetres, jarsBought   // the BOM for candles sold
                MaterialsCosts = CostDrv(waxKg.val, wickMetres.val, jarsBought.val, orders.val) => waxCost, wickCost, jarCost, boxCost // Direct costs based on materials consumed x cost per unit
            ```
            • Equivalent with spread operator:
            `   MaterialsCosts = CostDrv(...UnitsBought.val, orders.val) => waxCost, wickCost, jarCost, boxCost // Direct costs based on materials consumed x cost per unit`

        Rules and Interpretation:
            • ...ObjectName.attr expands into the list of all outputs from ObjectName, taking the specified attribute (.val, .cost, etc.) for each.
            • The order of inputs generated by the spread must match the order of outputs defined on the right-hand side.
            • The spread operator is optional — explicit input lists are always valid.

        Notes:
            • The spread operator can be used with any object type that requires an input per output (e.g. CostDrv, QuantDrv, RevDrv, CapexDrv, StaffDrv, SubMth), but not where a single input is essential (e.g. Split).
            • It improves readability and reduces repetition, but does not change the underlying logic.
            • One or more spread operators can be combined with explicit inputs, to use as inputs into another object.

    </Spread_operator>

    <Input_mapping>
        Objects that take inputs can be configured in two ways:
        • One-to-one mapping (1:1): Each output is driven by its own distinct input.
        `   MaterialsCosts = CostDrv(waxKg.val, wickMetres.val, jarsBought.val) => waxCost, wickCost, jarCost  // waxCost driven by waxKg, wickCost by wickMetres, jarCost by jarsBought`
        • One-to-many mapping (1:many): A single input is applied to all outputs when several costs share the same driver.
        `   FulfilmentCosts = CostDrv(Orders.val) => packagingCost, shippingCost  // both packagingCost and shippingCost driven by total Orders`

        Notes:
            • Inputs are always outputs from other objects (e.g. Orders.val).
            • Both 1:1 and 1:many mappings are valid. The choice depends on whether each cost stream has its own driver or shares a common one.

    </Input_mapping>

    <Object_variants>
        Some objects have variants that represent the same functional logic but ensure the resulting outputs are classified into the correct section of the P&L, or separated for key metrics (e.g. LTV).

        Examples of Quantity Driven variants where the step is either multiplying or dividing the input by the internal assumptions
        • QuantDrvMul() = Multiply the input by the internal assumption
        • QuantDrvDiv() = Divide the input by the internal assumption

        Examples of Cost-related variants (DC, SM, GA, RD, OE on end of objectName):
        • CostMthOE() = One-off or occasional company setup expenses entered monthly (Other Expenses)
        • CostMthGA() = One-off or occasional overheads entered monthly (General & Admin)
        • CostMthSM() = One-off or occasional acquisition and sales related expenses entered monthly (Sales & Marketing)
        • CostMthRD() = One-off or research, brand, patents expenses entered monthly (Research & Development)

        • CostDrvDC() = Driven Direct Costs (COGS)
        • CostDrvSM() = Driven Sales & Marketing (Acquisition costs)

        • CostAnnSM() = Budgeted Sales & Marketing (Acquisition costs)
        • CostAnnGA() = Budgeted General & Administrative (Overheads)
        • CostAnnRD() = Budgeted Research & Development (Product, Lab, Intellectual property, non-staff software development costs)

        Examples of Staff-related variants (for StaffTeam and StaffDrv objects):
        • StaffTeamGA() = Admin / G&A teams (e.g. Admin, finance, HR, legal, compliance, strategy ...)
        • StaffTeamSM() = Sales & Marketing teams, business development
        • StaffTeamRD() = R&D teams, product teams, software developers

        • StaffDrvDC() = Driven Customer-facing direct cost teams (fulfilment, operations, support, service)
        • StaffDrvSM() = Driven Customer-facing acquisition teams (sales, onboarding, integration, setup)

        Examples of Revenue-related variants (recurring vs one-off new revenues):
        • RevDrv() = Standard recurring revenues (e.g. product sales, subscriptions).
        • RevDrvNew() = New / one-off revenues (e.g. joining fees, setup fees, implementation fees). These are separated from recurring revenues for correct LTV calculations.

        Rules and Interpretation:
        • A variant works exactly the same as the base object in terms of inputs, assumptions, outputs, and attributes.
        • The only difference is classification in reporting or metrics — no extra logic is added.

        Examples:
            ```FM
            MaterialsCosts = CostDrvDC(...UnitsBought.val) => waxCost, wickCost, jarCost // Direct costs driven by units bought * cost per unit (using CostDrvDC for Direct Costs)
            AcquisitionCosts = CostAnnSM() => crmSubscription, eventSponsorship // Annual predictable acquisition costs (using CostAnnSM for Sales & Marketing costs)
            OnboardingRevenues = RevDrvNew(newCustomers.val) => joiningFeeRev, setupFeeRev // One-off onboarding revenues driven by new customers * fee per new customer
            ```

    </Object_variants>

    <Naming_conventions>

        • Name Casing
            - ObjectName: PascalCase (e.g. CustomerAcquisition, StaffRole, Subscriptions).
            - outputName: camelCase (e.g. ceo, financeTeam, bronzeSubs).
            - Attributes: dot notation, lower camelCase (e.g. .cost, .heads, .rev, .act, .chu, .life, .val, .cum, .assum).

        • Uniqueness
            - ObjectNames must be unique across the model.
            - outputNames must also be unique across the model (not just within each object).
            - This ensures you can safely use `outputName.attribute` without the need to prepend the ObjectName (which is NOT supported).

        • Short, descriptive names
            - ObjectNames should read like process step titles (e.g. CustomerForecast, BasketSize, ProductMix).
            - outputNames should be nouns or compound nouns, e.g. newCustomers, orders, items, shirtsSold.
            - outputNames should not contain examples, create a separate output for each example, e.g. "setup costs (legal, fitout, licenses)" should be 3 outputs "setupLegal, setupFitout, setupLicenses"

        • Chains of simple objects (objects with only .val and .cum)
            - Add a descriptive prefix or suffix to prevent duplication (e.g. shirtsSold, shirtsRev).
            - Common suffixes: ...Rev, ...Cost, ...Fees, ...Sold, ...Items, ...Units.
            - Common prefixes: new..., num...

        • Multi-output objects (e.g. Supply*(), Sub*(), Staff*())
            - Always use neutral nouns describing the product, component, tier, role, team, or category.
            - Do not embed measure words (e.g. cost, rev, heads, act, churn) into outputNames.
            - Attributes provide the measure context.
            - Good: bronzeSubs.rev, bronzeSubs.act, bronzeSubs.chu
            - Bad: activeBronzeUsers.act (ambiguous, since "active" duplicates the .act attribute and contradicts the .chu attribute).

    </Naming_conventions>

    <dashboard_guidelines>
        In the financial model, there is a dashboard containing tables and charts that summarise the key outputs.
        To populate this, at the end of the FM Code we add objects that create the dashboard.
        There are two objects that send their inputs to the dashboard, DashTable() and DashChart().

        1. DashTable() objects are added first.
        - Each section name will create a new table containing 1 or more DashTable objects.
        - Each DashTable input will create its own line in the table.
        - Rows from objects with multiple inputs are grouped into blocks to keep them visually distinct from other objects.

        2. DashCharts() are added below all tables.
        - Each DashChart object creates a chart.
        - DashChart objects can contain 1 or more inputs.
        - Each DashChart input creates a separate series in the object's chart (e.g. a stacked bar chart).
        - Charts in the same section are arranged in a grid next to each other.
        - Changing the section name creates a new grid of charts with a large section title above them.

        Tables and charts are expected to display similar information.

        Suggested sections: Examples of information in each section
        - Cash info: Funding sources, cash from operations investments and funding, cash balance
        - Acquisition: New & cum stores, leads or visitors by channel
        - Customer info: new customers, Lost customers (if relevant), active customers (if relevant), product or service split
        - Revenues by source: onboarding fees, product sales, subscription mrr, service or project income, rental income, ...
        - Summary level P&L: Use the built in outputs rather than creating them with code (see examples)
        - Headcounts by team: Object totals rather than individual roles
        - Assets owned: Inventory, assets bought or made to rent, equipment bought for production

        This is a guide only and if the business has other important information to show, please add it.
        The dashboard is a summary, so be selective about the information you include.
        We do NOT want to see every output from every object.

        Separate the DashTable part of the code with a comment like this:
        // -------- Dashboard TABLES --------

        Then between the DashTable and DashChart parts of the code add a comment like this:
        // -------- Dashboard CHARTS --------

    </dashboard_guidelines>

</FM_Code_Conventions>

<Object_specifications>

    <Setup_spec>

        ObjectType: Setup()

        Description:
        Essential object in every model that is used to set the model start month and year.

        Typical usage:
        - Add to every model as the **first** object

        Inputs (from other objects):
        - none

        Assumptions (inside the object):
        - Model start month and year

        Outputs:
        - None

        Output Attributes:
        - None

        Example FM Code (client project workload spread over months):
        ```FM
        Setup:
            ModelSetup = Setup() // Set model start month
        ```

        Notes / Interpretation:
        - Essential as first object otherwise model will not work

    </Setup_spec>

    <FundEquity_spec>

        ObjectType: FundEquity()

        Description:
        Models equity financing through the sale of shares.
        Each outputName corresponds to a funding round (e.g. startingCash, seedRound, seriesA).
        The object tracks cash raised from investors but does not create any repayment or interest obligations.

        Typical usage:
        - Recording initial founder capital and subsequent equity rounds.
        - Tracking cumulative investor financing over time.
        - Separating funding rounds for clear reporting and analysis.

        Inputs (from other objects):
        - None (this is a starting object).

        Assumptions (inside the object):
        - Amount raised in each funding round.
        - Date (month) when each round is received.

        Outputs:
        - One or more outputNames, each representing a funding round.
        • The first outputName must always be `startingCash`.
        • Additional rounds may include `seedRound`, `seriesA`, `seriesB`, etc.

        Output Attributes:
        - .val = equity raised in each month (cash inflow).
        - .cum = cumulative equity raised to date.
        - Attributes are available at both the object level (totals) and per-outputName.

        Example FM Code:
        `   EquityFunding = FundEquity() => startingCash, seedRound, seriesA   // cash raised from founders and investors`

        Notes / Interpretation:
        - `startingCash.val` = initial founder or investor cash injected at the start.
        - `seedRound.val` = equity raised in the seed round (month of transaction only).
        - `EquityFunding.cum` = total cumulative equity raised across all rounds.
        - No repayments or interest are generated — equity is permanent capital.

    </FundEquity_spec>

    <FundDebt_spec>

        ObjectType: FundDebt()

        Description:
        Models fixed term loans used to fund the business.
        Each outputName represents a specific loan facility with its own borrowing, interest, and repayment terms.
        The object supports both amortising loans and interest-only structures, with optional grace periods.
        SBA loans are sometimes available for startups, but bank loans would be unusual for early stage companies unless asset backed.

        Typical usage:
        - Modelling startup or expansion loans, e.g. SBA.
        - Tracking interest and repayments for multiple parallel loans.

        Inputs (from other objects):
        - None (this is a starting object).

        Assumptions (inside the object, set per loan/outputName):
        - Loan start date.
        - Amount borrowed.
        - Interest rate.
        - Grace period (no interest owed or accrued), often 0.
        - Interest-only period (before amortisation begins), can be 0 if only repayment loan.
        - Repayment term (number of months, for amortisation), can be 0 if only an interest only loan.

        Outputs:
        - One or more outputNames, each representing a loan facility.
        • Example: SBA loan, bankLoan, ventureDebt, equipmentLoan.

        Output Attributes:
        - .int = interest due in each month.
        - .raised = principal borrowed in each month.
        - .repaid = principal repaid in each month.
        - .mom = month-on-month change in outstanding debt.
        - .bal = cumulative balance of outstanding principal.
        - Attributes are available at both the object level (totals) and per-outputName.

        Example FM Code:
        `   DebtFunding = FundDebt() => sbaLoan, bankLoan, ventureDebt, equipmentLoan  // funding from loans with specific repayment terms`

        Notes / Interpretation:
        - `bankLoan.raised` = amount drawn down when the loan starts.
        - `bankLoan.int` = monthly interest charge, based on outstanding balance.
        - `bankLoan.repaid` = principal repayments according to amortisation schedule or balloon repayment.
        - `bankLoan.bal` = remaining balance outstanding.
        - `DebtFunding.bal` = total outstanding balance across all loans.
        - Grace periods delay both interest accrual and repayments until the grace window ends.
        - After an interest-only period, amortisation begins automatically if a repayment term is defined.

    </FundDebt_spec>

    <QuantMth_spec>

        ObjectType: QuantMth()
        Object Variants: None. Outputs are quantities not costs or revenues, so results are not sent to financial statements.

        Description:
        Provides starting assumptions with no inputs. Users enter values by month for each outputName.
        By default outputs are not sent to any financial statements.

        Typical usage:
        - Entering small or occasional quantities such as new B2B clients, new projects, clinic openings, or homes built.
        - Example: new clinics by country per month.

        Inputs (from other objects):
        - None

        Assumptions (inside the object):
        - Values entered when using the object become the outputs.

        Outputs:
        - One or more outputNames
        - Each outputName corresponds to a separate forecast line item, e.g. newClinicsUsa, newClinicsUk, newClinicsCanada

        Output Attributes:
        - .val = monthly user input values, e.g. clinics opening by month.
        - .cum = cumulative totals across months, e.g. total clinics open.
        - Attributes are available both at the object level (totals) and per-outputName.

        Example FM Code:
        `   NewClinics = QuantMth() => newClinicsUsa, newClinicsUk, newClinicsCanada   // number of new clinics opening each month by region`

        Notes / Interpretation:
        - `NewClinics.cum` = cumulative total clinics open across all outputs (USA + UK + Canada).
        - `newClinicsUk.val` = number of clinics opening in the UK by month.

    </QuantMth_spec>

    <QuantAnn_spec>

        ObjectType: QuantAnn()

        Object variants:
        - QuantAnn() = Annual quantity assumptions spread evenly across months.
        - QuantAnnSeas() = Annual quantity assumptions spread across months using a seasonality profile (% by calendar month).

        Description:
        Provides starting assumptions based on annual forecast values, rather than monthly inputs, typically used for larger quantities of things where we wouldn't want to manually enter them by month.
        - QuantAnn() spreads the annual forecast evenly across months.
        - QuantAnnSeas() spreads the annual forecast using seasonality percentages, allowing for monthly variation.

        Typical usage:
        - Use QuantAnn() when forecasting larger volumes where monthly entry would be cumbersome, and monthly variation is not important.
        • Examples: B2C user signups, stable ecommerce orders, new subscriber volumes.
        - Use QuantAnnSeas() when forecasting activities that follow a seasonal pattern.
        • Examples: travel bookings, gym memberships, medical patients, property rentals, ecommerce orders with peak months.

        Guidance on choice:
        - If seasonality is **unlikely**, use QuantAnn() for simplicity.
        - If seasonality is **expected**, use QuantAnnSeas() and the user will also set monthly seasonality percentages inside the object.
        - Both produce the same type of outputs; the only difference is how the annual values are spread across months.

        Inputs (from other objects):
        - None.

        Assumptions (inside the object):
        - Annual forecast values per outputName.
        - For QuantAnnSeas(): additional seasonality percentages for each calendar month (must sum to 100%).

        Outputs:
        - One or more outputNames.
        - Each outputName corresponds to a separate forecast line item (e.g. ecommerceUsers, travelBookings).

        Output Attributes:
        - .val = monthly values (annual forecast spread evenly or by seasonality profile).
        - .cum = cumulative total of quantities across months.
        - .assum = seasonality % assumption entered by the user by calendar month (available at outputName level only, and only for QuantAnnSeas()).

        Example FM Code (annual evenly spread):
        `   NewUsers = QuantAnn() => organicUsers, paidAdsUsers    // Annual forecasts for new users by source`

        Example FM Code (annual with seasonality):
        `   TravelBookings = QuantAnnSeas() => consumerBookings, corporateBookings // Annual seasonal forecasts for new users by source`

        Notes / Interpretation:
        - `NewUsers.val` = monthly users added, based on annual forecast ÷ 12.
        - `TravelBookings.val` = sum of all outputName level seasonal bookings.
        - `consumerBookings.assum` = seasonality % assumption by calendar month (QuantAnnSeas only).

    </QuantAnn_spec>

    <QuantDrv_spec>

        ObjectType: QuantDrv()

        Object Variants: 
        - QuantDrvMul() = Multiply the input by the user assumptions
        - QuantDrvDiv() = Divide the input by the user assumptions

        Description:
        Takes input values by month for each outputName and multiplies or divides them by the user’s monthly assumptions.
        By default outputs are not sent to any financial statements.

        Typical usage:
        - Used for conversion rates or scaling quantities.
        - Example: If the input is marketing spend and the assumption is cost per new customer (CPC), then the output is spend ÷ CPC = number of new customers.

        Inputs (from other objects):
        - One input for each output if they each require different source values, e.g. spend by channel.
        - Or a single input which will be applied to all outputs.
        - Inputs are always outputs from other objects (e.g. marketingSpend.val) at either the object level or an outputName.

        Assumptions (inside the object):
        - User-defined parameters internal to the object (e.g. CPC, conversion rates, items per order). These are not outputs of other objects.

        Outputs:
        - One or more outputNames.
        - Each outputName corresponds to a separate scaled input, e.g. new users from different channels.

        Output Attributes:
        - .val = scaled input by month (such as new users per month). Available both at the object level (totals) and per-outputName.
        - .cum = cumulative total of the scaled input across months, e.g. cumulative new customers acquired.  Available both at the object level (totals) and per-outputName.
        - .assum = assumption to multiply or divide by entered by the user. Available at outputName level only.

        Example Division:
        `   NewUsers = QuantDrvDiv(googleAdCost.val, facebookAdCost.val) => newGoogleUsers, newFacebookUsers  // New users driven by ad spend divided by CPC assumptions by channel`

        Example Multiplication:
        `   ItemsBought = QuantDrvMul(orders.val) =>  items  // Total items bought driven by orders multiplied items per order assumption`

        Notes / Interpretation:
        - `NewUsers.val` = total new users added across all outputs (Google + Facebook) per month.
        - `newGoogleUsers.val` = number of new users from Google ad spend per month.

    </QuantDrv_spec>

    <SubMth_spec>

        ObjectType: SubMth()

        Description:
        Models monthly subscription revenues and subscriber activity by tier.
        Choose this simple subscription object if every tier pays monthly and can churn monthly.
        Inputs must be the number of new subscribers per tier (the tier mix is not handled inside this object).
        The object applies internal assumptions for monthly price and churn rate by tier, and outputs recurring revenue, active subscribers, churn, and subscriber lifetime.

        Typical usage:
        - Forecasting SaaS or subscription-based businesses with one or more subscription tiers.
        - Examples:
            - Bronze, Silver, Gold membership levels.
            - Free, Basic, Premium app subscriptions.

        Inputs (from other objects):
        - One input per tier: number of new subscribers each month.
        - Typically preceded by an object that outputs new customers by tier, e.g. Split().
        • Example:
        ```FM
            NewSubscribers = Split(newCustomers.val) => newBronze, newSilver, newGold  // New subscribers have this mix of product tiers
            Subscribers = SubMth(newBronze.val, newSilver.val, newGold.val) => bronzeSubs, silverSubs, goldSubs    // Forecast subscriber retention and MRR by tier
        ```
        // Equivalent using spread operator (more concise):
        `    Subscribers = SubMth(...NewSubscribers.val) => bronzeSubs, silverSubs, goldSubs // Forecast subscriber retention and MRR by tier`


        Assumptions (inside the object):
        - Monthly price per tier.
        - Price inflation rate over time (objectName level)
        - Monthly churn % per tier.

        Outputs:
        - One or more outputNames, each representing a subscription tier (e.g. bronzeSubs, silverSubs, goldSubs).

        Output Attributes:
        - .rev = monthly recurring revenue (MRR), calculated as active subscribers × monthly price.
        - .act = active subscribers each month, accounting for new subscribers and churn.
        - .chu = number of subscribers who churn in a given month, calculated as prior month actives × churn %.
        - .life = average subscriber lifetime in months, calculated as 1 ÷ churn %.
        - .mrrnew = montlh recurring revenue added by new customers this month
        - .mrrchu = montlh recurring revenue lost by customers churning this month
        - All attributes are available both at the object level (totals across all tiers) and at the outputName level (per tier).

        Example FM Code:
        `   Subscribers = SubMth(...NewSubscribers.val) => bronzeSubs, silverSubs, goldSubs. // Forecast subscriber retention and MRR by tier`

        Notes / Interpretation:
        - `Subscribers.rev` = total monthly recurring revenue across all tiers.
        - `silverSubs.rev` = monthly recurring revenue from Silver tier subscribers.
        - `bronzeSubs.act` = number of active Bronze tier subscribers in a given month.
        - `goldSubs.life` = expected subscriber lifetime for Gold tier subscribers.

    </SubMth_spec>

    <SubTerm_spec>

        ObjectType: SubTerm()

        Object Variants:
        - SubTerm() = Subscriptions with contract terms, and payment terms, assumes cash received promptly.
        - SubTermDel() = Same as SubTerm but assumes cash received after a delay. Must be paired with DelRev()

        Description:
        Models paid, fixed-term subscriptions (e.g. 3/6/12-month contracts) with renewals only at term end, optional upfront billing (e.g. annual prepay), and full revenue recognition mechanics. Tracks billings, cash, recognized revenue, active contracts, churn at term boundaries, and deferred revenue (balance sheet). Every tier (outputName) can have different prices, contract lengths and payment intervals.

        Typical usage:
        - Termed plans with renewal at expiry (no mid-term churn).
        - Annual prepay vs. monthly billing options.
        - Need for correct P&L revenue, cash flow timing, and deferred revenue liability.

        Inputs (from other objects):
        - One input per tier/plan: number of new contract starts each month.

        Assumptions (inside the object):
        - Contract term length (months) per tier (e.g. 12).
        - Churn rate at term end (%) per tier (implies retention at boundary).
        - Price per term by tier; revenue recognition is straight-line across the active months of the term.
        - Price inflation rate over time (objectName level)
        - Billing cadence per tier: monthly / quarterly prepaid / annual prepaid.
        - Cash collection timing aligned to billing cadence.

        Outputs:
        - One or more outputNames, each representing a tier or a term/tier combination if terms can vary (e.g. monthlyPro, annualPro, monthlyEnterprise, annualEnterprise).

        Output Attributes:
        - .rev  = recognized revenue in the month (P&L).
        - .act  = active contracts in the month.
        - .chu  = contracts that end and do not renew (churn occurs only at term end).
        - .bill = value of invoices issued in the month (billings).
        - .life = average contract lifetime in months (can equal term if renewal=0%; otherwise reflects renewal rate).
        - .defer  = deferred revenue liability at month end (balance sheet).
        - .book = bookings, total new contract revenues won in the month
        - .mrrnew = mrr from new customers in that month
        - .mrrchu = mrr lost from customers churning in that month
        - .billnum = number of customers invoiced in the month
        - Attributes available at both object level (totals across plans) and per-outputName.

        Example FM Code (prompt payments):
        ```FM
            NewContracts = QuantAnnSeas()               => newPlans                   // Annual new contracts won with seasonality
            NewPlanMix   = Split(newPlans.val)          => newAnnual, newMonthly      // New clients sign up to this mix of payment plans
            Subscribers  = SubTerm(...NewPlanMix.val)   => subsAnnual, subsMonthly    // Subscriber retention at end of term, payments and mrr by tier
        ```

        Example FM Code (delayed payments, e.g. B2B invoiced with 30 day payment terms):
        ```FM
            NewContracts = QuantAnnSeas()                   => newPlans                 // Annual new contracts won with seasonality
            NewPlanMix   = Split(newPlans.val)              => newAnnual, newMonthly    // New clients sign up to this mix of payment plans
            Subscribers  = SubTermDel(...NewPlanMix.val)    => subsAnnual, subsMonthly  // Subscriber retention at end of term and mrr by tier. Invoices added to accounts receivable.
            Payments     = DelRev(Subscribers.rev)          => subsPaid                 // Payments received after N month delay (accounts received and cash in).
        ```

        Notes / Interpretation:
        - Upfront annual billing: `.bill` occurs at contract start and renewal for cohorts (used for cash in or accounts receivable); `.rev` is recognized straight-line during term; `.defer` carries the unrecognized balance and releases monthly.
        - Monthly billing: `.bill`, `.cash`, and `.rev` are typically aligned month by month; `.defer` is minimal unless billing in advance.
        - Churn only at boundary: mid-term churn is not modeled; use SubMth() if you need continuous (hazard-style) churn.

    </SubTerm_spec>

    <SubRetain_spec>

        ObjectType: SubRetain()

        Object Variants: None.

        Description:
        Models subscriber retention without any pricing / MRR. Takes new customers or users by tier and applies monthly churn % to produce active users and churn counts.
        Useful when retention is needed independently of revenue (e.g. retained ecommerce customers that do not need ad spend to drive repeat purchases).

        Typical usage:
        - Exclusively free/community tiers where no fee is charged (e.g. ad funded businesses like Facebook where we still need to model user retention).
        - Decoupling retention dynamics from monetisation (e.g. Amazon ecommerce customers, where after an initial purchase we have a probability of repeat purchases for each active user rather than fixed monthly subscriptions).

        Inputs (from other objects):
        - One input per tier: number of new customers each month (e.g. from Split() or Quant*()).

        Assumptions (inside the object):
        - Monthly churn % per tier (or equivalently, retention %).
        - Assumptions live at the outputName level.

        Outputs:
        - One or more outputNames, each representing a subscriber tier or cohort (e.g. free, beta, waitlist).
        - Outputs are subscriber states (actives/churn) only; no revenues or costs are produced.

        Output Attributes:
        - .act = active subscribers each month.
        - .chu = subscribers who churn in a given month (prior month actives × churn %).
        - .life = average subscriber lifetime in months, calculated as 1 ÷ churn %.
        - Attributes available at both object level (totals across all tiers) and per-outputName.

        Example FM Code:
        ```FM
            CustomersAcquired = QuantAnnSeas()                 => newCustomers     // Annual new customers with seasonality
            RetainedCustomers = SubRetain(newCustomers.val)    => customers        // Customers are retained after their initial purchase
        ```

        Notes / Interpretation:
        - No revenue is calculated in this object. Pair with monetisation elsewhere if needed (e.g. initial purchase by new customers plus probability of repeat purchases by retained customers each month).
        - `Retention.act` = total active retained customers across all tiers.
        - Works identically to SubMth’s retention mechanics but omits price and revenue for simplicity.

    </SubRetain_spec>

    <RevDrv_spec>

        ObjectType: RevDrv()

        Object variants: These variants of the object ensure revenues are classified correctly within the P&L and for metrics such as LTV.
        - RevDrv() = Standard recurring revenues, e.g. product sales.
        - RevDrvNew() = New / one-off revenues, e.g. joining fees, setup fees, implementation fees. These are separated from recurring revenues to allow correct LTV calculations.

        Description:
        Takes input quantities by month for each outputName and multiplies them by their unit prices to output revenues.
        The outputs represent monthly revenues, automatically classified into the appropriate recurring or one-off Revenue sections of the P&L.
        Applies where cash will be received quickly (e.g. credit card payment) so use for B2C. See RevDrvDel() for B2B.

        Typical usage:
        - Calculating recurring revenues from unit sales (internal unit price assumptions).
        - Calculating non-recurring “new” revenues such as onboarding or setup fees (internal fee per new customer assumptions).
        - Examples:
            - Units of each candle × price per candle = monthly revenue per product (use RevDrv).
            - Upsell customers × Upsell fee = monthly upsell revenue (use RevDrv).
            - New customers × joining fee = one-off joining revenue (use RevDrvNew).

        Inputs (from other objects):
        - One or more input quantities (e.g. `smallCandle.val`, `largeCandle.val`).
        - Spread operator can be used when each revenue output should match a set of input quantities.

        Assumptions (inside the object):
        - Unit price per outputName.
        - Price inflation rate over time (objectName level)
        - These are not outputs of other objects.
        - Multiplication only (division not supported).

        Outputs:
        - One or more outputNames.
        - Each outputName corresponds to a specific revenue stream (e.g. smallCandleRev, upsellRev).

        Output Attributes:
        - .val = monthly revenue (input quantity × unit price). Available at both object level (totals) and per-outputName.
        - .cum = cumulative monthly revenues. Available at both object level (totals) and per-outputName.
        - .assum = unit price entered by the user. Available at outputName level only.

        Example FM Code (recurring revenue):
        `   ProductRevenues = RevDrv(...Products.val) => smallCandleRev, largeCandleRev, giftSetRev    // Product revenues from units sold x unit price`

        Example FM Code (new / non-recurring revenue):
        `   OnboardingRevenues = RevDrvNew(newCustomers.val) => joiningFeeRev, setupFeeRev     // One-off revenues to setup new customers`

        Notes / Interpretation:
        - `ProductRevenues.val` = total monthly recurring revenues across all products.
        - `OnboardingRevenues.val` = total monthly non-recurring revenues from new customers.
        - `joiningFeeRev.val` = monthly joining fees from new customers.
        - `joiningFeeRev.assum` = unit joining fee per new customer.

    </RevDrv_spec>

    <RevDrvDel_spec>

        ObjectType: RevDrvDel()

        Object variants:
        - RevDrvDel() = Recurring revenues with a payment delay (used for B2B invoiced revenues).
        - RevDrvNewDel() = One-off or non-recurring revenues with a payment delay (e.g. joining fees, setup/implementation fees).

        Description:
        Works like RevDrv(), multiplying input quantities by unit price assumptions to generate revenues.
        Changes the cash output to Accounts Receivable to allow it to be paired with a DelRev() object.
        Revenue is recognised in the correct month, but goes to Accounts Receivable instead of cash in. The delayRev() object then handles Accounts Received and Cash in after an appropriate delay.

        Typical usage:
        - B2B revenues where customers are invoiced and payments are received after a delay.
        • Examples:
            - Monthly software licences invoiced with 30-day payment terms.
            - Implementation projects with milestone invoicing and delayed cash receipts.
            - Non-recurring onboarding or setup fees (use RevDrvDelNew).

        Inputs (from other objects):
        - One input per outputName (e.g. activeClients.val, unitsDelivered.val).
        - Or a single input applied across all outputNames.

        Assumptions (inside the object):
        - Price per unit or per customer.
        - Payment delay in months.

        Outputs:
        - One or more outputNames, each representing a revenue stream (e.g. softwareLicences, consultingProjects, setupFees).

        Output Attributes:
        - .val = revenue recognised in each month (as per RevDrv).
        - .cash = cash received in each month (revenue shifted by the payment delay).
        - .ar = Accounts Receivable balance outstanding, representing revenue earned but not yet collected.
        - Attributes are available at both object level (totals) and per-outputName.

        Example FM Code (one-time implementation fees with delay):
        ```FM
            ImplementationRevenues = RevDrvNewDel(newClients.val) => setupFees  // One-off setup fees invoiced to clients (RevenueNew and accounts receivable)
            SetupPayments = DelRev(setupFees.val) => setupPaid  // Setup invoices paid (accounts received and cash in)
        ```

        Example FM Code (recurring invoiced software revenue):
        ```FM
            SoftwareRevenues = RevDrvDel(activeClients.val) => softwareLicences     // Software licenses invoiced to clients (Revenue and accounts receivable)
            SoftwarePayments = DelRev(softwareLicences.val) => SoftwarePaid         // Software invoices paid (accounts received and cash in)
        ```

        Notes / Interpretation:
        - `softwareLicences.val` = recognised revenue in the correct delivery month.
        - `softwareLicences.cash` = cash collected, shifted forward by the payment delay.
        - `softwareLicences.ar` = balance of unpaid invoices, cleared when cash is received.
        - At object level, totals are available (e.g. `SoftwareRevenues.ar` = total Accounts Receivable across all outputs).

    </RevDrvDel_spec>

    <CostDrv_spec>

        ObjectType: CostDrv()
        Object variants: These variants of the object are for specific types of cost that need to appear in specific section within the P&L
        - CostDrvDC() = Driven costs that are Direct Costs (DC) or COGS and so need to appear in the Direct Costs section of the P&L. The input drivers will be things like products sold or active customers. e.g. candleWaxCosts, customerServiceCosts
        - CostDrvSM() = Driven costs that are Sales & Marketing (SM) or other customer acquisition costs and so need to appear in the Acquisition costs section of the P&L. Input drivers will be things like number of clicks or number of new customers. e.g. googleAdsCosts, customerOnboardingCost

        Description:
        Takes input quantities by month for each outputName and multiplies them by the user’s unit cost assumptions.
        This object always produces outputs expressed as costs.

        Typical usage:
        - Converting activity volumes or quantities into monthly costs.
        - Examples:
            - Number of items purchased × unit cost = monthly purchase cost.
            - Number of deliveries × cost per delivery = monthly logistics cost.

        Inputs (from other objects):
        - One input for each output if they each require different source quantities.
        - Or a single input which will be applied to all outputs.
        - Inputs are always outputs from other objects (e.g. `itemsBought.val`, `deliveries.val`).

        Assumptions (inside the object):
        - User-defined unit cost assumptions (e.g. cost per item, cost per delivery).
        - Cost inflation rate over time (objectName level)
        - These are not outputs of other objects.
        - Multiplication is the only operation — division is not supported.

        Outputs:
        - One or more outputNames.
        - Each outputName corresponds to a separate cost stream, e.g. materialsCost, deliveryCost.

        Output Attributes:
        - .val = monthly cost (input × unit cost assumption). Available at both object level (totals) and outputName level.
        - .assum = unit cost entered by the user. Available at outputName level only.

        Example with inputs for every output:
        `   MaterialsCosts = CostDrvDC(waxKg.val, wickMetres.val, jarsBought.val) => waxCost, wickCost, jarCost  // Direct product costs from consumed materials multiplied by respective unit costs`
        `   AcquisitionCosts = CostDrvSM(clicksGoogle.val, clicksFacebook.val) => googleAdsCost, facebookAdsCost  // Customer acquisition costs from ad clicks multiplied by CPC assumptions`

        Example with spread operator generating inputs for every output from the UnitsBought object:
        `   MaterialsCosts = CostDrvDC(...UnitsBought.val) => waxCost, wickCost, jarCost  // Direct product costs from consumed materials multiplied by respective unit costs`
        `   FulfilmentCosts = CostDrvDC(Orders.val) => packagingCost, shippingCost  // Fulfilment costs from total orders multiplied by each process unit costs`

        Notes / Interpretation:
        - `MaterialsCosts.val` = total material costs across all components (wax + wicks + jars) per month.
        - `waxCost.val` = monthly wax cost, based on kg needed × wax cost per kg.
        - `waxCost.assum` = wax cost per kg by month.
        - If using Supply*() elsewhere in the model that will handle product or component COGS automatically, so do not duplicate COGS with CostDrvDC(), but CostDrvDC() will still be needed for credit card fees, variable platform fees, fulfilment costs, etc.

    </CostDrv_spec>

    <CostAnn_spec>

        ObjectType: CostAnn()

        Object variants: These variants of the object are for specific types of cost that need to appear in specific sections within the P&L.
        - CostAnnGA() = Annual assumptions for predictable overhead costs (G&A) such as rent, utilities, insurance, software subscriptions.
        - CostAnnSM() = Annual assumptions for predictable Sales & Marketing (S&M) costs such as advertising budget, sponsorships, or marketing tools.
        - CostAnnRD() = Annual assumptions for predictable Research & Development (R&D) costs such as software licenses, design tools, or lab rental.
        - Note: Direct Costs (COGS / DC) are not covered by this object type. Direct costs should be driven by activity and use objects like `CostDrvDC()` instead.

        Description:
        Provides starting annual cost assumptions with no inputs.
        Users enter annual cost assumptions for each outputName, which the object converts into monthly cost outputs.

        Typical usage:
        - Forecasting predictable annual costs that can be spread evenly across months.

        Inputs (from other objects):
        - None

        Assumptions (inside the object):
        - User-defined annual cost assumptions for each outputName.
        - Cost inflation rate over time (objectName level)
        - These are not outputs of other objects.

        Outputs:
        - One or more outputNames.
        - Each outputName corresponds to a separate predictable cost line item (e.g. officeRent, insurance).

        Output Attributes:
        - .val = monthly cost. Available both at the object level (totals) and per-outputName.

        Example FM Code (overheads):
        `   OverheadCosts = CostAnnGA() => officeRent, utilities, insurance, softwareSubscriptions // Annual regular overhead costs by expense type`

        Example FM Code (acquisition costs):
        `   AcquisitionCosts = CostAnnSM() => crmSubscription, eventSponsorship    // Acquisition budgets by expense type`

        Example FM Code (R&D costs):
        `   DevelopmentCosts = CostAnnRD() => designSoftware, labRental    // Research & Development budgets by cost type`

        Notes / Interpretation:
        - `OverheadCosts.val` = total monthly overhead costs across all outputs.
        - `insurance.val` = monthly insurance cost.

    </CostAnn_spec>

    <CostMth_spec>

        ObjectType: CostMth()

        Object variants:
        - CostMthOE() = One-Off and setup costs not part of ongoing operations (Other Expense).
        - CostMthGA() = ad-hoc consultancy, irregular office expenses, occasional events or conferences (General & Administrative).
        - CostMthSM() = experimental campaign costs, conference spend, occasional trade fairs (Sales & Marketing).
        - CostMthRD() = prototype development costs, freelance researcher fees, patent and IP costs, trademarks (Research & Development).

        Description:
        Provides starting cost assumptions where the user directly enters monthly cost values.
        Behaves like CostAnn(), but instead of entering annual assumptions that are spread across months, the user defines the monthly values explicitly.
        Useful when costs are irregular or need to be entered directly by month.

        Typical usage:
        - Forecasting one-off or occasional monthly costs that don’t follow a smooth annual pattern.
        - Low value (non capitalised) expenses related to setting up the company

        Inputs (from other objects):
        - None.

        Assumptions (inside the object):
        - Monthly cost values entered per outputName. Most months can be zero.

        Outputs:
        - One or more outputNames, each representing a monthly cost stream (e.g. campaignCost, prototypeCost).

        Output Attributes:
        - .val = monthly cost entered by the user.
        - .cum = cumulative monthly cost.
        - Attributes available at both object level (totals) and outputName level.

        Example FM Code (Other Expense):
        `   CompanySetup = CostMthOE() => legalFees, companyRegistration, licenceFees  // One-off company setup costs in the month incurred`

        Example FM Code (G&A overheads):
        `   OccasionalCosts = CostMthGA() => consultancyFees, officeEvents     // Occasional overhead expenses in the month incurred`

        Example FM Code (Sales & Marketing):
        `   AcquisitionProjects = CostMthSM() => conferenceSponsorship, influencerTrialCampaign    // Occasional acquisition expenses in the month incurred`

        Example FM Code (R&D):
        `   DevelopmentProjects = CostMthRD() => prototypeDesign, freelanceResearchers, patentFees // Occasional Research & Development expenses in the month incurred`

        Notes / Interpretation:
        - `OccasionalCosts.val` = total monthly occasional costs across all included items.
        - `legalFees.val` = monthly legal fees, entered directly by the user.
        - Costs can vary month by month without needing an even spread or seasonality, and can be zero in many months.

    </CostMth_spec>

    <SupplyMths_spec>

        ObjectType: SupplyMths()

        Object Variants: None.

        Description:
        Models supplier purchasing with multi-month lead times and inventory management.
        Takes in demand (products, components, or raw materials), applies internal assumptions for target inventory levels, minimum order quantities (MOQs), case pack sizes (rounding above MOQ), lead times, and unit costs. The object:
        • Places purchase orders in advance.
        • Receives goods after the lead time and updates inventory.
        • Recognizes COGS when items are sold.
        • Tracks cash/prepayments and inventory value for the balance sheet.

        Typical usage:
        - Finished goods resold to customers (buy in bulk, then sell).
        - Component/material purchasing where product demand is converted to component demand via BOMs (use QuantDrv to create BOM for each product, then feed total requirements into SupplyMths by adding common component demand across products).
        - One Supply() object per model is enough as it can take as many inputs as needed. Add together demand from different channels (eg. DTC & Wholesale)

        Inputs (from other objects):
        - One input per outputName: the monthly demand series for each purchased item (product or component), e.g. `smallDress.val`, `buttons.val`.
        - Use the spread operator when inputs are 1:1 with outputs (e.g. `Supply(...ProductsSold.val)`).
        - For components shared across multiple products, compute component demand with `QuantDrv()` per product (its BOM), then combine shared components with `Sum()` before feeding component demand into `Supply()`.
        - If physical products come in different sizes and are being manufactured from raw materials, then add a step that converts demand for each size into a quantity of materials needed (e.g. use QuantDrv) and pass the object total into SupplyMths()

        Assumptions (inside the object):
        - Target inventory level per item (by month)
        - Unit cost per item (by month).
        - Cost inflation rate over time (objectName level)
        - Lead time in whole months (≥1).
        - MOQ per purchase order (units).
        - Case pack / order multiple (rounding unit above MOQ).
        - (Optional) Opening inventory (units and value) per item at model start.
        - (Default cash terms) Payment at order placement; prepaid amounts held as a balance sheet asset until receipt.

        Outputs:
        - One or more outputNames, each representing a purchased item (finished good or component), e.g. `blouses`, `zippers`.

        Output Attributes (per outputName and at object level totals):
        - .cogs   = Cost of goods sold in the month (P&L), based on units sold × unit cost from inventory.
        - .cost   = Cost of items bought in the month the order is placed (cash/balance sheet).
        - .nsell  = Number of items sold to customers in the month (equals input demand unless stockouts occur). If combining demand from DTC & wholesale channels then use each channel's demand to drive revenues rather than this output as they will have different prices.
        - .nbuy   = Number of items ordered from suppliers in the month (rounded for MOQ/case).
        - .nrec   = Number of items received into inventory in the month (arrivals after lead time).
        - .ninvent = Units held in inventory at month end.
        - .prepay = Value of prepaid orders not yet received (balance sheet asset).
        - .invent = Inventory value at month end (balance sheet asset).

        Mechanics & interpretation:
        - Ordering & sizing:
        • For each month t, the object looks ahead by `leadTime` to the receipt month t+L and sizes `nbuy[t]` to meet the target inventory level after forecast demand in the receipt period, rounding up to meet `MOQ` and `case pack` multiples.
        - Receipts:
        • `nrec[t]` equals `nbuy[t-L]` (orders placed L months earlier) after rounding and timing.
        - Inventory & sales:
        • Sales consume available inventory: `nsell[t]` reduces `ninven[t]`; COGS is recognized as inventory value released.
        • If available units are insufficient, `nsell` is capped by inventory + receipts (stockout behaviour). (No lost-sales line is output.)
        - Cash & balance sheet:
        • `cost[t]` represents cash outflow at order placement (prepayment by default).
        • Prepaid value accumulates in `.prepay` and reclassifies to `.invent` when items are received; inventory then releases to `.cogs` upon sale.

        Example FM Code — finished goods (buy → sell):
        ```fm
        // Demand by product
            CustomerOrders  = QuantAnnSeas() => orders  // Forecast annual orders with seasonality
            BasketItems     = QuantDrv(orders.val) => items // Items sold based on orders x items per order
            ProductsSold    = Split(items.val) => blousesSold, shortsSold, sweatersSold // Typical mix of items sold by product type

        // Total demand by product is fed into a single Supply() object
            Purchasing = SupplyMths(...ProductsSold.val) => blouses, shorts, sweaters   // Purchase products based on leadtimes, MOQ, supplier orders, inventory levels, COGS

        // Revenues (pricing handled separately)
            Revenues   = RevDrv(...ProductsSold.val) => blousesRev, shortsRev, sweatersRev  // Product revenues from demand x unit price by product
        ```

        Example FM Code — components with shared BOM parts:
        ```fm
        // Product demand by SKU
            ProductsSold = Split(items.val) => jackets, trousers    // Mix of demand by product

        // BOM per product (units of components per finished unit) - note that not all components are common, only trousers use rivets.
            JacketBOM   = QuantDrv(jackets.val)  => buttonsJkt, zipsJkt, fabricJkt   // Consumption based on component quantity needed per Jacket
            TrousersBOM = QuantDrv(trousers.val) => buttonsTrs, zipsTrs, fabricTrs, rivetsTrs  // Consumption based on component quantity needed per Trouser

        // Combine shared components across products
            ButtonsReq = Sum(buttonsJkt.val, buttonsTrs.val)
            ZipsReq    = Sum(zipsJkt.val,    zipsTrs.val)
            FabricReq  = Sum(fabricJkt.val,  fabricTrs.val)

        // Total requirements by component fed into a single Supply() object
            Components = Supply(ButtonsReq.val, ZipsReq.val, FabricReq.val, rivetsTrs.val) => buttons, zips, fabric, rivets    // Purchase components based on lead times/MOQs/case sizes
        ```
        Example FM Code — Different sized products made from raw materials:
        ```fm
        // Product demand by SKU
            ProductsSold    = Split(items.val)                      => smallCandles, mediumCandles, largeCandles    // Mix of demand by product

        // BOM per material (amount of materials per unit of finished product by size)
            WaxReq          = QuantDrv(...ProductsSold.val)         => smallWaxKg, mediumWaxKg, largeWaxKg   // Consumption based on a material quantity (kg of wax) needed per product
            WickReq         = QuantDrv(...ProductsSold.val)         => smallWickM, mediumWickM, largeWickM  // Consumption based on a material quantity (metres of wick) needed per product

        // Total requirements by material type fed into a single Supply() object
            Materials       = Supply(WaxReq.val, WickReq.val, items.val) => wax, wicks, boxes    // Purchase materials & components based on total demand for each and lead times/MOQs/case sizes
        ```

        Notes / guidance:
        - When there are common components / materials you can structure the intermediate BOM logic either by component or by product:
        -- Use a BOM per product where there are many more components than products (clothing example)
        -- Use a BOM per component where there are many more products than components (candle example)
        -- If numbers of products and components are similar, then prefer BOM by component / material, as it doesn't need the Sum() steps to calculate total requirements by component / material.
        - Use either `SupplyMths()` **or** a separate `CostDrvDC()` for product COGS — not both. When SupplyMths() is used, it already computes COGS; do not double-count.
        - When using SupplyMths(), CostDrvDC() will still be needed for credit card fees, variable platform fees, fulfilment costs, etc.
        - Opening inventory can be seeded to reflect stock on hand at model start (assumption is inside object).
        - Use the spread operator for clean 1:1 input→output wiring when purchasing many items. SupplyMth() inputs can contain multiple spread operators and/or inputs from other objects.

    </SupplyMths_spec>

    <CapexMth_spec>

        ObjectType: CapexMth()

        Object variants:
        - None

        Description:
        Allows manual entry of capital investments in the month they are incurred.
        Similar to CostMth except the spend is capitalised and depreciated over time.

        Typical usage:
        - Forecasting one-off, setup or occasional monthly capex that doesn't follow a smooth annual pattern.
        - e.g. when setting up the company, one-off purchases of high value, long life equipment that are not expected to be replaced (use CapexEquip if equipment will be replaced in under 3-5 years)
        - Typically only higher value purchases are capitalised (e.g. over $1000), for low value setup costs use CostMth

        Inputs (from other objects):
        - None

        Assumptions (inside the object):
        - Monthly capex values entered per outputName. Most months can be zero.

        Outputs:
        - One or more outputNames, each representing a category of one-off capex (e.g. officeChairs, officeDesks, officePrinters).

        Output Attributes:
        - .val = monthly capex entered by the user.
        - .depr = depreciation of historic purchases
        - Attributes available at both object level (totals) and outputName level.

        Example FM Code (Capitalised setup costs):
        `   CompanySetup = CapexMth() => officeFurniture, officeFitout  // One-off high value capitalised company setup costs in the month incurred`

        Notes / Interpretation:
        - CompanySetup.val = total amount spent on capitalised setup by month
        - officeFurniture.val = amount spent on capitalised furniture by month
        - CompanySetup.depr = total amount of depreciation related to historic company setup expense

    </CapexMth_spec>

    <CapexProj_spec>

        ObjectType: CapexProj()

        Description:
        Models the capital expenditure (capex) associated with a series of phased construction projects (e.g. new stores, factories, housing developments, ships).
        Each project’s investment is spread over multiple months according to category-specific spending profiles.
        When multiple projects start in different months, their investment profiles overlap and sum together in the outputs.
        Lifetime assumptions generate straight-line depreciation for each investment category, and cost inflation ensures later projects are more expensive.

        Typical usage:
        - Forecasting investment needs for projects that involve multiple categories of spending, with overlapping schedules.
        • Examples:
            - New retail stores (design, permissions, construction, fitout, equipment).
            - Factories or data centers (site preparation, machinery, systems).
            - Projects that are later sold as finished goods (housing, ships, aircraft builds).
        - Do NOT use to standalone equipment (i.e. that isn't part of a larger project), nor for one-off setup investments. CapexMth or CapexEquip are better for that.

        Inputs (from other objects):
        - A single inputName (e.g. `newStores.val`, `newFactories.val`, `newProjects.val`).
        - Input values indicate the number of new projects starting in each month.
        - Instead of a simple count (e.g. `1`), the input can be scaled to represent relative cost factors (e.g. `1.5` = 150% of baseline project cost).
            • This allows some projects to be modelled as larger or smaller than average, while preserving the mix of spending categories.
        - The same input applies to all outputNames (investment categories).

        Assumptions (inside the object):
        - Spending profile for each investment category: allocation of total spend across months relative to project start (e.g. -3m to +6m).
        - Unit cost per project by category (baseline).
        - Inflation rates to adjust project costs in future years.
        - Lifetime in months for each category, used to calculate straight-line depreciation.

        Outputs:
        - One or more outputNames, each representing an investment category (e.g. design, permissions, construction, fitout, equipment).

        Output Attributes:
        - .val = actual capex spend in each month (summing overlapping projects).
        - .depr = monthly depreciation expense, based on accumulated investments and their lifetimes.
        - .proj = total investment per project start month, locked to the start date (not spread).
            • Used when projects are later sold and must be moved from Assets into COGS.
            • Example: building houses or ships — investment accumulates over months, sits on the balance sheet as work-in-progress, then `.project` value is charged to COGS when the unit is sold.
        - Attributes are available at both object level (totals) and per-outputName.

        Example FM Code (houses with relative costs applied before CapexProj):
        `   HouseScalars = QuantDrv(newHouses.val) => houseSizeFactor  // Scalar for house costs in each month relative to typical cost`
        `   HouseCapex = CapexProj(houseSizeFactor.val) => land, foundations, build, interiors // scaled investments for new houses in each month phased around completion date`

        Example FM Code (retail store projects):
        `   StoreCapex = CapexProj(newStores.val) => design, permissions, construction, fitout, equipment  // Investments in new stores by cost type phased around opening month`

        Notes / Interpretation:
        - If `newStores.val = 1` in Jan-25 and `1` in Jul-25, both projects’ spending schedules overlap and are summed into `StoreCapex.val`.
        - If the Jul-25 store is 150% larger than average, its input can be passed as `1.5` instead of `1`, scaling all category costs proportionally.
        - Inflation ensures later projects cost more than earlier ones.
        - `StoreCapex.depr` = ongoing depreciation of accumulated investments.
        - `StoreCapex.proj` = the full investment for each project, locked to the start month, for use in later inventory/COGS treatment when projects are sold.

    </CapexProj_spec>

    <CapexEquip_spec>

        ObjectType: CapexEquip()

        Description:
        Models capitalised equipment that provides productive capacity or is rented out to customers.
        The object compares demand each month against installed capacity, automatically purchasing new equipment when required and replacing old equipment at end of life.
        All cash, capex, depreciation, and residual values are calculated internally.

        Typical usage:
        - Operational equipment with defined productivity and finite lifespan.
        • Examples:
            - Manufacturing machines producing units per month.
            - Rental fleets (cars, trucks, equipment) meeting customer usage demand.
            - IT servers or hardware with defined throughput and replacement cycles.

        Inputs (from other objects):
        - Option A: A single input applied to all outputNames (e.g. total demand across all products).
        - Option B: Separate inputs for each outputName (e.g. demand per product line or per process step).
        - Input values represent the required demand to be met in each month (e.g. widgets needed, rental days, transactions).

        Assumptions (inside the object):
        - Productivity: units handled per machine per month (per outputName if different categories are defined).
        - Unit purchase price of equipment.
        - Lifetime in months.
        - Residual value at end of life.
        - Cost inflation (increases purchase prices for future acquisitions).

        Outputs:
        - One or more outputNames, each representing a category of equipment.
        • If one input is applied to all outputs, each category scales to the same demand input.
        • If multiple inputs are provided, each outputName is driven by its own demand input.

        Output Attributes:
        - .val = capex spend in each month on new equipment purchases.
        - .depr = monthly depreciation of all equipment owned.
        - .nbuy = number of units purchased in that month.
        - .nown = number of units owned in that month (cumulative).
        - .nsell = number of units retired at end of life and sold for residual value in that month.
        - Attributes are available both at object level (totals) and per-outputName.

        Example FM Code (single input applied to all equipment categories):
        `   FactoryEquip = CapexEquip(widgetDemand.val) => mouldingMachines, assemblyRobots, packagingLines    // Equipment purchased to meet overall demand based on productivity by machine`

        Example FM Code (different demand inputs per equipment type):
        `   FactoryEquip = CapexEquip(mouldedUnits.val, assembledUnits.val, packagedUnits.val) => mouldingMachines, assemblyRobots, packagingLines  // Equipment purchased to meet demand by process step based on productivity of each step`

        Example FM Code (rental cars replaced every 12 months):
        `   RentalFleet = CapexEquip(rentalDays.val) => cars   // Car purchases based on rental demand and asset life`

        Example FM Code (rental cars by size mix):
        ```FM
            RentalDemand = QuantAnnSeas() => rentalDays  // total rental demand (seasonal)
            CarMix = Split(rentalDays.val) => economyDays, standardDays, suvDays  // split demand into car size mix
            RentalFleet = CapexEquip(...CarMix.val) => economyCars, standardCars, suvCars  // Car purchases based on rental demand and asset life by car size`
        ```
        // Outputs track per-size fleets and costs
        // economyCars.nown = number of economy cars owned by month
        // economyCars.val = monthly spend on new economy cars
        // RentalFleet.val = total fleet investment across all sizes

        Notes / Interpretation:
        - Demand is compared against installed capacity for each equipment type each month.
        - If demand exceeds capacity, new units are purchased.
        - At the end of equipment life, units are retired, residual value recovered, and replacement purchases made if demand persists.
        - Inflation increases purchase prices over time, while depreciation follows lifetime assumptions.
        - `FactoryEquip.nown` shows installed base of each machine type; `.nbuy` and `.nsell` show monthly changes.
        - `FactoryEquip.capex` = cash spent acquiring equipment across all categories.
        - `FactoryEquip.depr` = depreciation expense across all owned equipment.

    </CapexEquip_spec>

    <StaffRole_spec>

        ObjectType: StaffRole()

        Description:
        Models the cost and headcount of individual staff roles.
        Users enter assumptions for each role (e.g. start date, annual salary, tax %, bonus %), and the object produces monthly staff costs and headcount.
        This object has no inputs from other objects — all assumptions are internal.

        Typical usage:
        - Defining members of the leadership team or other individually specified key roles.
        - Examples:
            - CEO
            - Operations Manager
            - Head of Marketing
            - Finance Manager

        Inputs (from other objects):
        - None

        Assumptions (inside the object):
        - Start date & end dates for the role.
        - Annual salary.
        - Employer taxes and on-costs (percentage of salary).
        - Bonus or performance-related pay (percentage of salary).
        - Wage inflation by role per year.

        Outputs:
        - One or more outputNames.
        - Each outputName corresponds to a specific staff role (e.g. ceo, headOfMarketing).

        Output Attributes:
        - .val = monthly cost of the role (salary + taxes + bonus from the start date).
        - .heads = monthly headcount contribution (1 while role is active, 0 before start date).
        - Attributes are available both at the object level (totals) and per-outputName.

        Example FM Code:
        `   LeadershipTeam = StaffRole() => ceo, operationsManager, headOfMarketing, financeManager    // Leadership salaries and start dates by role`

        Notes / Interpretation:
        - `LeadershipTeam.val` = total monthly leadership team cost across all roles.
        - `ceo.val` = monthly cost of the CEO (salary + tax + bonus).
        - `ceo.heads` = 1 when the CEO is employed, 0 otherwise.

    </StaffRole_spec>

    <StaffTeam_spec>

        ObjectType: StaffTeam()

        Object variants: These variants of the object are for specific types of staff teams that need to appear in specific sections within the P&L.
        - StaffTeamGA() = Overheads (G&A) staff teams, such as finance, HR, admin, legal.
        - StaffTeamSM() = Sales & Marketing staff teams, such as marketing, partnerships, sales support, business development.
        - StaffTeamRD() = Research & Development (R&D) staff teams, such as product development, design, software developers.
        - Note: Direct Costs (COGS / DC) are not covered by this object type. Direct costs should be driven by activity and use objects like `CostDrvDC()` instead.

        Description:
        Models the cost and headcount of staff organised into teams.
        Users enter assumptions for each team (e.g. start date, number of staff, average salary, tax %, bonus %), and the object produces monthly team costs and headcount.
        This object has no inputs from other objects — all assumptions are internal.

        Typical usage:
        - Forecasting administrative or functional teams where staff are grouped rather than modelled individually.
        - Examples:
            - Finance team
            - Marketing team
            - General administration

        Inputs (from other objects):
        - None

        Assumptions (inside the object):
        - Start date of the team.
        - Initial number of staff, and over time.
        - Annual salary per staff member (average).
        - Wage inflation rate over time by team.
        - Employer taxes and on-costs (percentage of salary).
        - Bonus or performance-related pay (percentage of salary).

        Outputs:
        - One or more outputNames.
        - Each outputName corresponds to a specific team (e.g. financeTeam, marketingTeam).

        Output Attributes:
        - .val = monthly team cost (team headcount × [monthly salary + taxes + bonus], by month from the start date).
        - .heads = monthly headcount of the team (number of staff active in each month).
        - Attributes are available both at the object level (totals) and per-outputName.

        Example FM Code (Overheads):
        `   CentralTeams = StaffTeamGA() => financeTeam, hrTeam, adminTeam // Central Teams headcounts and average salaries by type of team`

        Example FM Code (Sales & Marketing):
        `   AcquisitionTeams = StaffTeamSM() => marketingTeam, partnershipsTeam, salesTeam // Sales & Marketing headcounts and average salaries by type of team`

        Example FM Code (R&D):
        `   DevelopmentTeams = StaffTeamRD() => productDesignTeam, labTeam, frontEndDevs, backEndDevs // Development Teams headcounts and average salaries by type of team`

        Notes / Interpretation:
        - `CentralTeams.val` = total monthly cost across all central teams.
        - `financeTeam.val` = monthly cost of the finance team (headcount × [salary + taxes + bonus] ÷ 12).
        - `financeTeam.heads` = number of finance staff in each month.

    </StaffTeam_spec>

    <StaffDrv_spec>

        ObjectType: StaffDrv()

        Object variants: These variants of the object are for driven teams that need to appear in specific sections within the P&L.
        - StaffDrvDC() = Direct Cost (DC) or COGS staff driven by product or customer related activity, such as fulfilment staff, warehouse staff or customer service.
        - StaffDrvSM() = Sales & Marketing (SM) staff driven by acquisition related activity (e.g. number of leads, new customers), such as sales or onboarding staff.

        Description:
        Models the cost and headcount of staff teams where headcount is driven by business activity.
        User assumptions define the staff-to-activity productivity ratio (e.g. orders handled per head, active customers per head), along with salary, tax, and bonus assumptions.
        The object then scales staff costs and headcount based on the input activity divided by team productivity.

        Typical usage:
        - Forecasting customer-facing teams that grow in proportion to demand or transactions.
        - Examples:
            - Fulfilment heads driven by orders per month.
            - Customer support heads driven by active customers per month.
            - Sales heads driven by leads per month.

        Inputs (from other objects):
        - One or more activity drivers from other objects (e.g. `Orders.val`, `ActiveCustomers.val`).
        - Inputs must represent the specific activity type that drives the number of staff needed.

        Assumptions (inside the object):
        - Staff productivity (e.g. 500 customers per head).
        - Annual salary per staff member (average).
        - Wage inflation by team.
        - Employer taxes and on-costs (percentage of salary).
        - Bonus or performance-related pay (percentage of salary).

        Outputs:
        - One or more outputNames.
        - Each outputName corresponds to a specific staff team driven by activity (e.g. fulfilmentTeam, supportTeam).

        Output Attributes:
        - .val = monthly team cost (driven headcount × [monthly salary + taxes + bonus]).
        - .heads = monthly headcount of the team (driven by activity).
        - Attributes are available both at the object level (totals) and per-outputName.

        Example FM Code (Direct Cost team):
        `   FulfilmentTeams = StaffDrvDC(Orders.val) => warehouseTeam, shippingTeam  // Fulfilment team headcount scales with total orders`

        Example FM Code (Sales & Marketing team):
        `   SalesTeams = StaffDrvSM(NewCustomers.val) => salesTeam, onboardingTeam  // Sales team headcounts scale with new customers`

        Notes / Interpretation:
        - `FulfilmentTeams.val` = total monthly cost across all fulfilment-related teams.
        - `warehouseTeam.heads` = number of warehouse staff each month, based on orders ÷ staff-per-orders assumption.
        - `supportTeam.val` = monthly cost of customer support staff, based on active customers × staff ratio × (salary + taxes + bonus).

    </StaffDrv_spec>

    <StaffLoc_spec>

        ObjectType:
        StaffLoc()

        Object variants (classification for P&L placement):
        • StaffLocSM() – Sales & Marketing location staff (e.g., all store staff).
        • StaffLocDC() – Direct Cost / service delivery location staff (e.g., clinicians, dentists, hairdressers, nurses, manucurist, solicitors, who deliver the service).

        Description:
        Scales fixed per-location staffing (roles and cost) from the count of active locations.
        Each outputName represents a role (e.g., manager, receptionist, security).
        Internal assumptions set roles-per-location, salaries, on-costs, and wage inflation.
        Outputs provide monthly headcount and cost at both role and object (total) levels.

        Inputs (from other objects):
        • Exactly one input: monthly series of active locations (e.g., newStores.cum).
        • For pre-opening hiring, advance the locations with AdvQuant() before feeding into StaffLoc().

        Assumptions (inside the object):
        • Roles per location (can be fractional).
        • Annual salary per role; employer taxes & on-costs (%); bonus (%).
        • Wage inflation per role (or object-level).

        Outputs:
        • One or more outputNames (roles): manager, receptionist, security, …
        • Attributes (available at object and role level):
            - .heads = (active locations × roles per location) by month.
            - .val  = .heads × (salary + taxes + bonus)/12, with wage inflation.

        Pairing with activity-driven teams (StaffDrv*()):
        Why:
            • StaffLoc* handles fixed “per site” staffing.
            • Real operations also need variable staffing that scales with activity (e.g., footfall, patients, orders).
            • Use StaffDrv*() to model teams whose headcount is driven by activity/productivity.

        How:
            • Choose the correct StaffDrv variant for P&L classification:
                - StaffDrvDC() for service/COGS delivery teams driven by activity (e.g. doctors, dentists).
                - StaffDrvSM() for all store based staff driven by footfall, customers.
            • Feed StaffDrv*() an activity driver (e.g., footfall.val, patients.val, orders.val, activeCustomers.val).
            • Set productivity (activity per head), salaries, on-costs, bonuses, wage inflation inside StaffDrv*().
            • Combine costs across StaffLoc* and StaffDrv* with object totals or Sum() when you need a consolidated line.

        Pitfalls to avoid:
            • Don’t double-count fixed roles in StaffDrv*()—keep fixed per-location roles in StaffLoc*().
            • Don’t push activity-driven roles into StaffLoc*()—that belongs in StaffDrv*().
            • Use AdvQuant() for hiring ahead of opening (e.g., hire 1–2 months before opening).

        Example FM Code (fixed per-location + variable activity-driven teams):
        ```FM
        Locations:
            NewSites        = QuantMth() => newStores                       // New store openings by month
            LtStoreFootfall = QuantDrv(newStores.val) => ltFootfall         // Long term expected footfall for each new store
            RampedFootfall  = Ramp(ltFootfall) => footfall                  // footfall ramps up over time to LT max by months after opening

        StoreStaffing:
            StoreStaff      = StaffLocSM(activeStores.val) => manager, security, backoffice, reception  // Number of each role added in each open location
            VariableTeams   = StaffDrvSM(footfall.val) => floorTeam, cashiers   // Variable staff driven by store footfall
        ```

    </StaffLoc_spec>

    <Split_spec>

        ObjectType: Split()

        Description:
        Takes a single input quantity by month and allocates it across multiple outputs based on internal percentage mix assumptions.
        The total of all outputNames will always equal the input.

        Typical usage:
        - Splitting total items or total revenues into a product mix.
        - Examples:
            - Total items sold split into small candles, large candles, gift sets.
            - Total revenue split into domestic vs. international sales.
            - Total new customers split into subscription tiers, free, basic, premium.

        Inputs (from other objects):
        - Exactly one input quantity (e.g. `customerItems.val`).

        Assumptions (inside the object):
        - Mix % for each outputName.
        - Mix values may change over time (monthly percentages).
        - Assumptions are not outputs of other objects.

        Outputs:
        - One or more outputNames.
        - Each outputName corresponds to a share of the input quantity.

        Output Attributes:
        - .val = allocated monthly quantity for that output. Attributes are available both at the object level (totals) and per-outputName.

        Example FM Code:
        `   ProductsSold = Split(customerItems.val) => smallCandles, largeCandles, giftSets    // Product mix of items sold`

        Notes / Interpretation:
        - `ProductsSold.val` = total items (equal to input so better to use input source instead).
        - `smallCandle.val` = number of small candles per month (customerItems × smallCandle mix%).

    </Split_spec>

    <Sum_spec>

        ObjectType: Sum()

        Description:
        Aggregates multiple inputs into a single object-level total.
        The object produces a summed output across all inputs, with both monthly and cumulative totals available.

        Typical usage:
        - Combining outputs from **different objects** into a single total.
        - Summing a **subset of outputs within the same object** (when you don’t want the full object total).
        - Examples:
            - Summing different product revenues into total revenue.
            - Summing marketing and sales costs into a combined acquisition cost line.

        Important note:
        - Every object already provides a built-in total at the object level (e.g. `ObjectName.val`, `ObjectName.cost`).
        - Therefore, `Sum()` is **not needed** to get the total of all outputs within a single object — it is only useful when combining across objects or subsets of outputs in the same object.

        Inputs (from other objects):
        - Two or more input values (e.g. `smallCandleRev.revenue`, `largeCandleRev.revenue`).
        - Inputs are always outputs from other objects.

        Assumptions (inside the object):
        - None.

        Outputs:
        - A single object-level total output.

        Output Attributes:
        - .val = monthly sum of all input values.
        - .cum = cumulative total across months.
        - Attributes are only available at the object level (not per input, since inputs are passed in rather than defined as outputs).

        Example FM Code (sum outputs from multiple objects):
        `   TotalRevenues = Sum(smallCandleRev.revenue, largeCandleRev.revenue, giftSetRev.revenue)    // Sum of revenues from different sources`

        Notes / Interpretation:
        - `TotalRevenues.val` = monthly total revenue across the selected product lines.
        - `TotalRevenues.cum` = cumulative revenue across the selected product lines.

    </Sum_spec>

    <DelQuant_spec>

        ObjectType: DelQuant()

        Description:
        Shifts an input quantity forward in time by a specified number of months.
        Functionally the opposite of AdvQuant() — equivalent to using AdvQuant() with a negative delay.
        The number of months delayed is set as an internal assumption.

        Typical usage:
        - Reflecting real-world lags between an event and its impact.
        • Examples:
            - Delay new sales heads before they generate leads or clients (ramp-up time).
            - Delay active clients (or cumulative new clients) before they start using services (onboarding / integration period).
            - Delay new projects (or cumulative new projects) before they become revenue-generating (construction or setup time).

        Inputs (from other objects):
        - One input quantity series (e.g. `salesHeads.val`, `newClients.cum`, `newProjects.cum`).

        Assumptions (inside the object):
        - Delay period in months (integer).

        Outputs:
        - One or more outputNames, each corresponding to a delayed version of the input.

        Output Attributes:
        - .val = monthly values of the input shifted forward by the delay period. Available both at the object level (totals) and per-outputName.
        - .assum = number of months delay being applied by month (the internal assumption). Available per-outputName only.

        Example FM Code (allow time for onboarding and integration before new clients become active):
        `   DelayedStartClients = DelQuant(newClients.val) => onboardedClients // New clients complete onboarding after a few months`
        `   Subscribers = SubMth(onboardedClients.val) => subscribingClients   // Subscribers become active once they are onboarded`

        Notes / Interpretation:
        - `onboardedClients.val` = delayed series of new clients (e.g. if delay = 3 months, January clients appear in April).
        - Useful for chaining into downstream objects (e.g. service usage, revenues) with realistic timing.

    </DelQuant_spec>

    <AdvQuant_spec>

        ObjectType: AdvQuant()

        Description:
        Shifts an input quantity backward in time (into earlier months) by a specified number of months.
        Functionally the opposite of DelQuant() — equivalent to using DelQuant() with a negative delay.
        The number of months advanced is set as an internal assumption.

        Typical usage:
        - Bringing forward activity relative to its driver.
        • Examples:
            - Advance project resource requirements (e.g. staff planning starts months before projects go live).
            - Advance marketing effort relative to customer acquisition (campaigns precede new customer numbers).
            - Advance production or procurement relative to expected sales (stock built in advance).

        Inputs (from other objects):
        - One input quantity series (e.g. `newProjects.val`, `newCustomers.val`).

        Assumptions (inside the object):
        - Advance period in months (integer).

        Outputs:
        - One or more outputNames, each corresponding to an advanced version of the input.

        Output Attributes:
        - .val = monthly values of the input shifted earlier by the advance period. Available both at the object level (totals) and per-outputName.
        - .assum = number of months advance being applied by month (the internal assumption). Available per-outputName only.

        Example FM Code (bring forward marketing campaigns relative to new customers):
        ```FM
            LeadsNeeded   = QuantDrv(newCustomers.val) => qualifiedLeads    // Multiple leads are needed for each new customer
            AdvancedLeads = AdvQuant(marketingLeads.val) => marketingLeads   // Leads must be genrated months in advance of winning a new customer
        ```

        Notes / Interpretation:
        - `marketingLeads.val` = advanced series of new customers (e.g. if advance = 2 months, leads to generate March customers are needed in January).
        - Useful for modelling upstream activities that must happen ahead of their main driver.

    </AdvQuant_spec>

    <DelRev_spec>

        ObjectType:
        DelRev()

        Description:
        Converts recognized revenue into cash collections by applying a payment delay.
        Takes revenue inputs (e.g., from SubTermDel() or RevDrvDel() using their .rev attributes), applies an
        internally-set delay in months (can be fractional) per outputName, and posts the value to:
            • Accounts Received (balance sheet)
            • Cash In (cash flow)
        Exposes a single attribute .val that represents cash collected by month. Object-level totals and per-outputName series are available.

        Typical usage:
        • Pair with SubTermDel() and RevDrvDel() which also send revenue to Accounts Receivable (balance sheet).
        • Use a single total collection stream, or per-outputName collections when payment terms differ by tier.

        Inputs (from other objects):
        • One or more revenue series (e.g., ...Subscriptions.rev, OnboardingRevenues.rev).
        • 1:1 mapping or 1:many supported.
        • Use spread operator when passing per-tier revenues: `DelRev(...Subscribers.rev) => paidBronze, paidSilver, paidGold`.

        Assumptions (inside the object):
        • Payment delay per outputName in months; may be fractional (e.g., 1.5 months).

        Outputs:
        • One or more outputNames representing cash collection streams (e.g., cashInTotal, paidBronze, paidSilver, paidGold).

        Output Attributes:
        - .val = monthly cash collected for that outputName (and at object total).
        - .assum = number of months delay being applied by month (the internal assumption). Available per-outputName only.

        Examples (Pairing with SubTermDel(): Single total revenue stream → single cash-in stream)
        ```FM
            Subscriptions     = SubTermDel(...TierMix.val)      => bronzeUsers, silverUsers, goldUsers  // B2B Client contract terms, retention, mrr and invoiced amounts by tier
            Collections       = DelRev(Subscriptions.rev)       => subscriptionsPaid    // All client invoices are paid after a short delay
        ```
        Example (Pairing with SubTermDel(): recognized revenue to AR, collections via DelRev)
        ```FM
            Subscribers       = SubTermDel(...TierMix.val)      => bronzeSubs, silverSubs, goldSubs // B2B Client contract terms, retention, mrr and invoiced amounts by tier
            CollectionsByTier = DelRev(...SubscribersDel.rev)   => paidBronze, paidSilver, paidGold // Client invoices paid with option for different delays by tier
        ```
        Example (pairing with RevDrvNewDel(): One-off revenues with delayed payment terms)
        ```FM
            OnboardingFees    = RevDrvNewDel(newCustomers.val)  => setupFees        // Setup rev recognised and clients invoiced for setup work (accounts receivable)
            SetupCollections  = DelRev(setupFee.rev)            => setupFeesPaid    // Setup invoices paid after a delay (accounts received and cash in)
        ```

        Notes & guidance:
        • Use DelRev with the *Del variants* (SubTermDel/RevDrvDel/RevDrvNewDel). Do not also pipe non-Del objects that already post cash directly, or you will double-count cash.
        • Negative delays are generally not recommended; if used, they represent prepayments (cash before revenue) and will produce a negative AR until revenue is recognized.
        • Object-level `.val` equals the sum of all outputNames’ cash collections.

    </DelRev_spec>

    <Ramp_spec>

        ObjectType: Ramp()

        Description:
        Models the gradual build-up of an input value over time using a ramp profile of monthly percentages.
        Each input series provides long-term steady-state values introduced in specific months.
        The ramp profile determines how much of each input contributes in each subsequent month (“months since start”).
        Contributions from all start months are summed into outputs.

        Important note:
        - Every input value permanently contributes according to the ramp curve in all future months.
        - If units may end (e.g. store closures, contract expiries), that must be modelled in a subsequent step.

        Typical usage:
        - Modelling adoption or ramp-up where values are assumed to persist indefinitely once added.
        • Examples:
            - Customers from new store or clinic openings.
            - Output capacity from new factories.
            - Long-term activity or usage added by new projects.

        Inputs (from other objects):
        - One input per outputName, representing the long-term steady-state value added when new units start.
        - Input values can represent **anything that ramps** (number of units, expected LT footfall, patient capacity, etc.).
        • If inputs are “number of stores”, then a later step must scale by typical footfall.
        • If inputs are “LT footfall per new store”, then Ramp() directly produces total footfall, but LT values are locked in unless scaled later.
        - Inputs are monthly series — zero in months with no starts, non-zero in months with new starts.

        Assumptions (inside the object):
        - Ramp profile = percentages by “months since start” (e.g. 10%, 20%, 50%, 75%, 100%).
        - These percentages multiply each month’s input value and persist indefinitely once started.

        Outputs:
        - One or more plural outputNames, representing the accumulated ramped totals for each category.
        • Example: bostonStoreCustomers, londonClinicPatients, factoryOutputs.

        Output Attributes:
        - .val = monthly ramped value (sum of all active contributions from past starts).
        - .mom = month-on-month change in .val, representing incremental new contributions added.
        - Attributes are available both at the object level (totals) and per-outputName.

        Example FM Code:
        `   StoreCustomers = Ramp(newBostonStoresCust.val, newlondonStoresCust.val) => bostonStoresCustomers, londonStoresCustomers    // Store customers ramp up over time since opened by city`

        Notes / Interpretation:
        - If `newBostonStoresCust.val = 1,000` LT customers in Mar-25 and the ramp is [10%, 20%, 50%...],
        → contributes 100 in Mar, 200 in Apr, 500 in May, and so on.
        - If another 800 LT customers are added in Sep-25, their ramp overlaps and both are summed.
        - `StoreCustomers.val` = total monthly customers across all stores and start months.
        - `StoreCustomers.mom` = incremental customers added that month across all stores.
        - Ramp() is not suitable for modelling activities with a finite life (e.g. contract ends, store closures) — those must be handled in a later step.

    </Ramp_spec>

    <Spread_spec>

        ObjectType: Spread()

        Description:
        Spreads each month’s input value forward across N months using internal assumptions.
        Each input in a given month creates a stream of outputs spread over the following months, and all overlapping spreads are summed.
        Useful for modelling projects or clients that generate workloads, costs, or revenues gradually over a defined implementation or delivery period.

        Typical usage:
        - Professional services projects (e.g. consulting, architecture) where project size is spread across multiple months of delivery.
        - Implementation projects for new B2B clients, where onboarding costs or workloads are spread over N months.
        - Any activity where a one-off input creates sustained effort or cost across several months.

        Inputs (from other objects):
        - One input time series (e.g. `projectsWon.val`, `newClients.val`).
        - Each value represents the total size of new work or clients starting in that month.

        Assumptions (inside the object):
        - Spread duration (N months).

        Outputs:
        - One or more outputNames representing the spread series.
        • Example: clientImplementation, projectDelivery, consultingWorkload.

        Output Attributes:
        - .val = monthly values equal to the sum of all overlapping spreads generated by past inputs.
        - Attributes are available at both object level (totals) and per-outputName.

        Example FM Code (client project workload spread over months):
        ```FM
            ClientsWon          = QuantMth()                    => newClients       // small number of big projects entered in month won
            ResourceNeeded      = QuantDrv(newClients.val)      => hoursNeeded      // Project total resource needed based on # project and hours per client assumption
            ActiveProjects      = Spread(consultingHours.val)   => hoursBilled      // spread total hours needed over typical project durations
        ```

        Notes / Interpretation:
        - If `hoursNeeded.val = 100` in Jan and spread = 2 months, output will be 50 in Jan, 50 in Feb.
        - Spread() reshapes the timing of inputs, but does not change their total value (sum of spreads = original input).

    </Spread_spec>

    <ResTax_spec>

        ObjectType: ResTax()

        Description:
        Essential object in every model that is used to calculate corporation tax.

        Typical usage:
        - Add to every model
        - Include in results section near the end of every model (before dashboard)

        Inputs (from other objects):
        - none

        Assumptions (inside the object):
        - Tax rate
        - Payment interval
        - Anchor month
        - Payment delay

        Outputs:
        - One outputName (always "Tax")

        Output Attributes:
        - .rate = % tax due on taxable profits
        - .due = tax due at end of each payment interval
        - .paid = tax paid after delay
        - .taxable = calculation of amount of tax owing accounting for accumulated losses and interval's profits

        Example FM Code (client project workload spread over months):
        ```FM
            CorporationTax = ResTax() => Tax // Determine corporation tax due and paid accounting for any historic losses
        ```
        Notes / Interpretation:
        - None

    </ResTax_spec>

    <ResDcf_spec>

        ObjectType: ResDcf()

        Description:
        Essential object in every model that is used to calculate company valuation using discounted cash flow.

        Typical usage:
        - Add to every model
        - Include in results section after ResTax object

        Inputs (from other objects):
        - none

        Assumptions (inside the object):
        - Discount rate
        - Perpetual Growth Rate
        - Valuation year (to discount back to)

        Outputs:
        - None

        Output Attributes:
        - None

        Example FM Code (client project workload spread over months):
        ```FM
            Valuation = ResDcf() // Company valuation using Discounted Cash Flow (DCF) calculation
        ```

        Notes / Interpretation:
        - None

    </ResDcf_spec>

    <DashTable_spec>

        ObjectType: DashTable()

        Object variants (how monthly data should be aggregated):
        • DashTableSum() – Add every month to calculate annual values. Choose when values are a an amount consumed or generated in the period, e.g. revenues, costs, new stores, funds raised
        • DashTableCum() – Use the final month to show the final value. Choose when values are a cumulative amount, e.g. active clients, headcounts, Open Stores, cash balance, debt balance

        Description:
        Used to create tables of key results in the model dashboard.
        Multiple DashTable objects are ALWAYS included near the end of every models FM Code.

        Typical usage:
        - Add to every model
        - Add after results section

        Inputs (from other objects):
        - One to many inputs. Each input becomes a table row.
        - If inputs all represent similar things then they can be in one object and it is then helpful to add a total input too. If they are very different concepts (i.e. adding them together would NOT make sense) then use separate objects.
        - Prefer a single spread operator when we are adding every output from an object to a table.
        - The financial model generates standard outputs for most parts of the P&L, Cash Flow, and Balance sheet. These always start with 'output_', e.g. 'output_cum_cash'.
        - Standard outputs are often used in the dashboard and avoid having to calculate results manually with FM Code.
        - Standard outputs do not have any attributes, but inputs from other objects in the FM code must **ALWAYS** be followed by the correct attribute (e.g. .val)

        Assumptions (inside the object):
        - None

        Outputs:
        - None

        Output Attributes:
        - None

        Example FM Code (show cash info in a dashboard table using standard outputs):
        ```FM
        CashFlow:
            SourcesAndUses  = DashTableSum(output_cash_ops, output_total_investments, output_total_financing)    // important to include in every model
            CashBalance     = DashTableCum(output_cum_cash)    // important to include in every model
        ```

        Example FM Code (show orders by channel in a dashboard table):
        ```FM
        OrderSummary:
            KpiWebOrders = DashTableSum(...WebOrders.val)  // Show new orders by channel
        ```

        Notes / Interpretation:
        - Section names group multiple DashTable objects together in the same table. The section name becomes the title of the table.
        - DashTable ObjectNames should reflect the names of their inputs parent object, so prepend "Kpi" to the source object's name. If inputs are from multiple objects or use the model's standard outputs (e.g. "output_cum_cash") then choose a higher level name.


    </DashTable_spec>

    <DashChart_spec>

        ObjectType: DashChart()

        Object variants (how monthly data should be aggregated):
        • DashChartSum() – Add every month to calculate annual values. Choose when values are a an amount consumed or generated in the period, e.g. revenues, costs, new stores, funds raised
        • DashChartCum() – Use the final month to show the final value. Choose when values are a cumulative amount, e.g. active clients, headcounts, Open Stores, cash balance, debt balance

        Description:
        Used to create charts of key results in the model dashboard.
        Multiple DashChart objects are ALWAYS included at the end of every models FM Code.

        Typical usage:
        - Add to every model
        - Add after results section, and after DashTable objects

        Inputs (from other objects):
        - One to many inputs. Each input becomes a chart series.
        - If inputs all represent similar things then they can be in one object. If they are very different concepts (i.e. adding them together would NOT make sense) then use separate objects.
        - Prefer a single spread operator when we are adding every output from an object to a chart.
        - The financial model generates standard outputs for most parts of the P&L, Cash Flow, and Balance sheet. These always start with 'output_', e.g. 'output_cum_cash'.
        - Standard outputs are often used in the dashboard and avoid having to calculate results manually with FM Code.
        - Standard outputs do not have any attributes, but inputs from other objects in the FM code must **ALWAYS** be followed by the correct attribute (e.g., .val)
        - When including multiple similar inputs like customer by channel or headcounts by team, whereas in DashTable it is helpful to also include an input showing the total, we do **not** in DashChart as the top of the stacked bars in the chart alredy shows the total.

        Assumptions (inside the object):
        - None

        Outputs:
        - None

        Output Attributes:
        - None

        Example FM Code (show cash info in 2 dashboard charts using standard outputs):
        ```FM
        CashFlow:
            SourcesAndUses  = DashChartSum(output_cash_ops, output_total_investments, output_total_financing)    // important to include in every model
            CashBalance     = DashChartCum(output_cum_cash)    // important to include in every model
        ```

        Example FM Code (show orders by channel in a single dashboard stacked bar chart):
        ```FM
        OrderSummary:
            KpiWebOrders = DashChartSum(...WebOrders.val)  // Show new orders by channel
        ```

        Notes / Interpretation:
        - Section names group multiple DashChart objects together into a grid of multiple charts. The section name becomes the title of the grid.
        - DashChart ObjectNames should reflect the names of their inputs parent object, so prepend "Chart" to the source object's name. If inputs are from multiple objects or use the model's standard outputs (e.g. "output_cum_cash") then choose a higher level name.


    </DashTable_spec>

</Object_specifications>

<Design_patterns_guide>

    <boilerplate_code>
        Every model needs some standard objects adding otherwise it won't work
        ```FM
        // BusinessName: <INSERT NAME>
        // BusinessType: <INSERT CATEOGRISATION INFO>
        // DateTime: <INSERT DATE & TIME> // Use

        SetupAndFunding:
            Setup           = Setup()                           // Set model start date
            EquityFunding   = FundEquity()  => startingCash     // Sources of cash from investors

        ////
        // model logic goes in the middle - construction, customer acquisition, retention, revenues, people, costs, assets
        ////

        Results:
            Tax             = ResTax()      => tax      // Determine corporation tax due and paid accounting for any historic losses
            Valuation       = ResDcf()                  // Valuation of the business using a discounted cash flow (DCF) calculation


        //Dashboard: summary outputs for dashboard KPI tables and Dashboard charts follow

        // DashTable object are listed first
        CashFlow:   // These use standard outputs from the model financials and can be identical in every model
            KpiSourcesAndUses  = DashTableSum(output_cash_ops, output_total_investments, output_total_financing)    // include in every model
            KpiCashBalance     = DashTableCum(output_cum_cash)     // include in every model

        // DashTable for assets (e.g. cum stores, clinics, homes to rent, equipment purchased), customer acquisition, retention
        // DashTable for Revenue sources (e.g. onboarding, subscriptions, product sales, rentals)

        IncomeStatement: // include in every model
            KpiIncome       = DashTableSum(output_total_revenue, output_total_cogs, output_total_gross_margin, output_total_cust_acquis, output_total_overheads, output_total_prod_dev, output_ebitda, output_total_depreciation, output_ebit, output_total_other_expinc, output_net_profit)

        // DashTable for team headcounts and total headcount

        // DashChart objects are listed last
        CashFlowCharts:
            SourcesAndUses  = DashChartSum(output_cash_ops, output_total_investments, output_total_financing)    // include in every model
            CashBalance     = DashChartCum(output_cum_cash)        // include in every model

        // DashChart for construction, customer acquisition, retention
        // DashChart for Revenue sources
            ChartRevenues   = DashChartSum(output_total_revenue)
            ChartExpenses   = DashChartSum(output_total_cogs, output_total_cust_acquis, output_total_overheads, output_total_prod_dev, output_total_depreciation, output_total_other_expinc)
            ChartProfit     = DashChartSum(output_net_profit)
        // Other DashChart objects summarising other key client outputs follow...

        ```

        Others objects are optional but should normally be included with outputNames tailored to each business
        ```FM
        People:
            CentralTeams    = StaffTeamGA() => financeTeam, marketingTeam            // exclude for early stage startups and add roles to StaffRole() instead
            Leadership      = StaffRole()   => ceo, cfo, headProduct, headMarketing, headOperations  // replace these outputNames with their business roles. Common to have 'Head of' or director roles for any teams listed in StaffTeam

        Costs:
            Overheads       = CostAnnGA()   => rent, utilities, travel, software, insurance, accountingFees, bankingFees, communications, officePostage, officeSupplies, otherOverheads   // every company will have a long list of appropriate annual overheads
            SetupCosts      = CostMthOE()   => companySetup, legalFees, companyLicenses, otherSetupCosts, consultingFees  // list of one-off costs to start company
        ```

    </boilerplate_code>

    <section_order>
        Every model will contain multiple sections.
        Each section groups together related objects.
        Section names should be chosen to represent the combined purpose of the objects within them.

        Once you have decided on the logical flow of information between objects and the grouping of objects into sections, you should sort the sections into an order similar to this:
        1 - Setup & funding
        2 - Customer acquisition related sections
        3 - Revenue model related sections (onboarding, product sales, service delivery, subscriptions, rental, etc.)
        4 - People related sections (driven teams, location based teams, central teams, leadership roles)
        5 - Cost related sections (driven costs, overhead costs, one-off costs)
        6 - Capex related sections (driven capex, project or location capex, one-off setup capex)
        7 - Results (tax, valuation)
        8 - Dashboard (tables then charts)
    </section_order>

    <example_models>

        <b2c_saas_upsell_early_pattern>
            When to use:
            - Selling large numbers of consumer facing tiered subscriptions online (>1000s per month)
            - active users occasionally buy additional products or services

            Key choices:
            - B2C high numbers of users, health industry is seasonal so use QuantAnnSeas() to forecast new customers
            -- B2C so likely to use advertising to win customers, and unlikely to use a sales team
            -- Organic visitors are often included as a separate source and they are not driven by advertising
            - Subscriptions core to the business, consumer facing and monthly so choose SubMth()
            - Reselling products so no assembly or manufacturing needed
            - As they have physical products the model should use SupplyMths() to manage the supply chain.

            Skeleton:
            Early SaaS health app with tiered subscriptions and supplement upsells.
            ```fm
            SetupAndFunding:
                Setup               = Setup()                                         // Set model start date
                EquityFunding       = FundEquity()  => startingCash                   // Initial cash from founders/investors

            CustomerAcquisition:
                Acquisition         = QuantAnnSeas() => socialCustomers, organicCustomers // New customers by source with Q1-heavy seasonality (annual totals spread by seasonality)
                TierMix             = Split(Acquisition.val) => newFree, newBoosted, newUnlimited // Mix of new customers choosing Free/Boosted/Unlimited tiers

            Subscriptions:
                Subscribers         = SubMth(...TierMix.val) => freeSubs, boostedSubs, unlimitedSubs // Monthly subscription pricing & churn by tier; MRR, actives, churn, lifetime

            SupplementsDemand:
                SuppOrders          = QuantDrv(Subscribers.act) => suppBuyers        // % of active subscribers buying supplements each month (buyers/orders per month)
                SuppPacks           = QuantDrv(suppBuyers.val) => suppPacks          // Packs per order (typ. 2 packs each order)

            SupplyChain:
                SuppPurchasing      = SupplyMths(suppPacks.val) => supplements       // Purchase & hold stock of supplement packs; lead time, MOQ, inventory, COGS handled

            Sales:
                SupplementsRevenue  = RevDrv(supplements.nsell) => supplementsRev    // Revenue from supplements; only when inventory available (.nsell)

            People:
                Leadership          = StaffRole() => ceo, cfo, headMarketing, opsManager // CEO, CFO, Head of Marketing, Supplements ops role; salaries, taxes, bonus, start dates
                DevTeams            = StaffTeamRD() => appDevs, backEndDevs, aiDevs   // Small developer team; heads × (salary + on-costs)
                TotalHeads          = Sum(Leadership.heads, DevTeams.heads)           // Total company headcount across roles & teams

            Costs:
                AcqCosts            = CostDrvSM(socialCustomers.val) => socialAdsCost // Paid social acquisition cost driven by CPA per paid new customer
                PlatformFees        = CostDrvDC(Subscribers.val) => appStoreFees      // App store fees charged as % of subscriber revenues
                ServiceCosts        = CostDrvDC(Subscribers.act) => hostingCost, inferenceCost // Cost per active user for hosting & inference
                FulfilmentCosts     = CostDrvDC(suppBuyers.val) => packingCost, shippingCost   // Packing & shipping per supplements order (per buyer)
                Overheads           = CostAnnGA() => servicedOffice, insurance, travel, software, storageSpace // Annual cost of serviced office, insurance, travel, per-seat software, warehouse storage fee

            Capex:
                StaffDevices        = CapexEquip(TotalHeads.val) => laptops, phones   // Laptops & phones purchased per staff head; replacements at end of life
                EquipPlan           = CapexMth() => labelPrinter, barcodeScanner, otherEquip     // One-off high value equipment to setup company entered in month bought

            Results:
                CorporationTax      = ResTax() => Tax                                 // Corporation tax due & paid with losses carried forward
                Valuation           = ResDcf()                                        // Company valuation using DCF

            // ------- Dashboard tables (add key KPIs only) -------
            CashFlow:
                KpiSourcesAndUses   = DashTableSum(output_cash_ops, output_total_investments, output_total_financing) // include in every model
                KpiCashBalance      = DashTableCum(output_cum_cash)                             // include in every model

            Acquisition:
                KpiNewCustomers     = DashTableSum(...Acquisition.val)                  // New customers by channel (social vs organic)
                KpiCustomerChange   = DashTableSum(Acquisition.val, Subscribers.chu)    // Total new customers, churned customers
                KpiCustomerActive   = DashTableCum(Subscribers.act)                     // Total active subscribers

            RevenuesBySource:
                KpiRevenues         = DashTableSum(Subscribers.val, supplementsRev.val) // Subscription MRR and Supplements revenue

            HeadcountsByTeam:
                KpiHeads            = DashTableCum(Leadership.heads, DevTeams.heads, TotalHeads.val) // Leadership roles, Dev team headcounts and total heads

            SummaryIncomeStatement:
                KpiIncome           = DashTableSum(output_total_revenue, output_total_cogs, output_total_gross_margin, output_total_cust_acquis, output_total_overheads, output_total_prod_dev, output_ebitda, output_total_depreciation, output_ebit, output_total_other_expinc, output_net_profit)

            // ------- Dashboard charts (mirror key tables, split where a stacked bar chart doesn't make sense to add series together i.e. different units) -------
            CashFlowCharts:
                SourcesAndUsesChart = DashChartSum(output_cash_ops, output_total_investments, output_total_financing)
                CashBalanceChart    = DashChartCum(output_cum_cash)

            CustomerInfoCharts: // need to split into separate DashChart objects as a stacked chart doesn't make sense as we have different concepts in each series
                SubsNew             = DashChartSum(...Acquisition.val)                           // Chart for new customers by channel
                SubsChurn           = DashChartSum(Subscribers.chu)                              // Chart for churning customers
                SubsActive          = DashChartCum(Subscribers.act)                              // Chart for Active customers

            IncomeStatementCharts:
                RevenueMixChart     = DashChartSum(Subscribers.val, supplementsRev.val)
                OperatingCosts      = DashChartSum(output_total_cogs, output_total_cust_acquis, output_total_overheads, output_total_prod_dev, output_total_depreciation, output_total_other_expinc)  // standard outputs so same in every model
                ProfitBeforeTax     = DashChartSum(output_net_profit)                            // standard outputs so same in every model

            HeadcountCharts:
                HeadsChart          = DashChartCum(Leadership.heads, DevTeams.heads)             // Note that although we included TotalHeads.val in the Dashboard table above, we do **not** in the stacked bar chart as that would duplicate the values in all the other series
            ```
        </b2c_saas_upsell_early_pattern>

        <b2c_ecommerce_early_pattern>
            When to use:
            - Selling small quantities of physical products online (100s per month), or an early stage startup

            Key choices:
            - Reselling products so no assembly or manufacturing needed
            - B2C so will use advertising to win customers, and unlikely to use a sales team
            - Organic visitors are often included as a separate source and they are not driven by advertising
            - Ecommerce typically starts the model logic with order forecasts unless user asks to start with advertising budget (then drive orders from advertising budget using CPC step to leads, and a conversion rate step to new customers)
            - b2c / dtc ecommerce will typically have large numbers of new customers, so customer forecasts would use QuantAnnSeas()
            - Use QuantAnn() if the business has no seasonal variations in customer demand
            - As they have physical products the model should use SupplyMths() to manage the supply chain for resold products, or components used for their manufacture.
            - With small early stage companies, you should prefer lists of people in StaffRole and avoid having lots of central teams (teams like HR, strategy, finance are only found in larger comapnies)

            Skeleton:
            Early small Ecommerce reselling products through own website with no assembly or manufacturing needed
            ```fm
            //setup would come before this line

            CustomerOrders:
                WebOrders     = QuantAnnSeas()              => advertOrders, organicOrders           // forecast ad driven and free organic orders
                Basket        = QuantDrv(WebOrders.val)     => items                                 // Basket size from items per order

            SupplyChain:
                ProductsSold  = Split(items.val)                => prodSoldA, prodSoldB, prodSoldC   // product mix %
                Suppliers     = SupplyMths(...ProductsSold.val) => prodA, prodB, prodC               // handles supplier leadtimes, MOQ, inventory, COGS

            Sales:
                Revenues      = RevDrv(...Supply.nsell)     => prodRevA, prodRevB, prodRevC          // only generate revenue if inventory available to fulfil orders so use number sold '.nsell'

            People:
                Leadership      = StaffRole()               => ceo, cfo, headProduct, headMarketing, headOperations, supportRole1, otherRole1, otherRole2  // replace outputNames with ones suitable for their company

            Costs:
                Advertising   = CostDrvSM(advertOrders.val) => AdvertCost                            // Ad costs driven by typical cost per acquisisition (CPA)
                Fulfilment    = CostDrvDC(WebOrders.val)    => packagingCost, outboundShippingCost   // unit cost of packaging and delivery
                Overheads     = CostAnnGA()                 => rent, utilities, software, insurance, otherOverhead1, otherOverhead2  // Annual overheads. This can be a long list suitable for their company
                OneOffCosts   = CostMthOE()                 => companySetup, legalFees, otherSetup1  // list of one-off costs to start company

            //Dashboard objects would be added below...
            ```
        </b2c_ecommerce_early_pattern>

        <b2c_ecommerce_mature_pattern>
            When to use:
            - Selling large quantities physical products online (>1000s per month), growth stage or mature company

            Key choices:
            - Mature vs early ecommerce pattern adds an extra funnel step (conversion rate and cpc), and adds central teams and driven teams for customer support
            - Reselling products so no assembly or manufacturing needed
            - B2C so likely to use advertising to win customers, and unlikely to use a sales team
            - Organic visitors are often included as a separate source and they are not driven by advertising
            - Typically start with order forecasts unless user asks to start with advertising budget (then drive new customers via CPC)
            - b2c / dtc ecommerce will typically have large numbers of new customers, so customer forecasts would use QuantAnnSeas()
            - Use QuantAnn() if the business has no seasonal variations in customer demand
            - As they have physical products the model should use SupplyMths() to manage the supply chain for resold products, or components used for their manufacture.

            Skeleton:
            Mature Ecommerce reselling products through own website with no assembly or manufacturing needed
            ```fm
            //setup would come before this line

            CustomerOrders:
                WebOrders     = QuantAnnSeas()              => advertOrders, organicOrders           // combination of ad driven and free organic customers
                AdvertVisitors= QuantDrv(advertOrders.val)  => adVisitors                            // Multiply advertOrders by visitors per order to give visitors needed
                Basket        = QuantDrv(WebOrders.val)     => items                                 // items per order

            SupplyChain:
                ProductsSold  = Split(items.val)                => prodSoldA, prodSoldB, prodSoldC   // product mix %
                Suppliers     = SupplyMths(...ProductsSold.val) => prodA, prodB, prodC               // handles supplier leadtimes, MOQ, inventory, COGS

            Sales:
                Revenues      = RevDrv(...Supply.nsell)     => prodRevA, prodRevB, prodRevC          // only generate revenue if inventory available to fulfil orders so use number sold '.nsell'

            People:
                CustomerSupport = StaffDrvDC(WebOrders.val) => supportTeam                           // Customer support driven by total orders
                FulfilmentTeam  = StaffDrvDC(WebOrders.val) => fulfilTeam                            // Picking and packing driven by total orders
                MarketingTeam   = StaffTeamSM()             => mktgTeam                              // Marketing team heads set manually
                CentralTeams    = StaffTeamGA()             => financeTeam, legalTeam, hrTeam        // Central admin team heads set manually
                Leadership      = StaffRole()               => ceo, cfo, headProduct, headMarketing, headOperations, otherRole1, otherRole2  // Leadership team roles

            Costs:
                Advertising   = CostDrvSM(adVisitors.val)   => AdvertCost                            // Ad costs driven by visitors multiplied by the typical cost per click (CPC)
                Fulfilment    = CostDrvDC(WebOrders.val)    => packagingCost, outboundShippingCost   // unit cost of packaging and delivery
                Overheads     = CostAnnGA()                 => rent, utilities, software, insurance, otherOverhead1, otherOverhead2  // Annual overheads. This can be a long list suitable for their company
                OneOffCosts   = CostMthOE()                 => companySetup, legalFees, otherSetup1  // list of one-off costs to start company

            //Dashboard objects would be added below...
            ```
        </b2c_dtc_ecommerce_website_mature_pattern>

        <combining_objects_with_common_theme>
            When to use:
            - If you have multiple rows in a section using the same object and they relate to a similar concept, then combine them into a single object, particularly when they share the same inputs.

            Key choices:
            - The idea behind each combined row should be similar and have the same units, e.g. they all relate to conversion rates for different channels, or the time required for different process steps, or the prices for different products, etc. 
            - The objectType & variant must be the same

            Skeleton:
            Generalise the ObjectName to cover the combined rows and then merge inputs and outputs
            ```
            // these rows all relate to process time and share the same ObjectType and inputs so do not need to be three separate rows
            DesignCheckHrs      = QuantDrv(NewClients.val) => designCheckHrs        // Hours to check AI design per new client (hrs per client)
            BuildModelHrs       = QuantDrv(NewClients.val) => buildHrs              // Hours to build financial model per new client (hrs per client)
            FollowupHrs         = QuantDrv(NewClients.val) => followupHrs           // Hours for post-delivery call/video per new client (hrs per client)

            // They can be combined into a single object row
            ModelHrs            = QuantDrv(NewClients.val) => designCheckHrs, buildHrs, followupHrs     // Hours to check AI design, build the model, and for post delivery call/video (hrs per client model)
            ```
        </combining_objects_with_common_theme>

    </example_models>

</Design_patterns_guide>

<Task_and_Output_Checklist>
• Setup the boilerplate code. The model design will go inside it.
• Choose the right objects from <Object_specifications>; **only** include objects that are needed.
• Use the right object variant to classify P&L correctly (CostDrvDC/SM, CostAnnGA/SM/RD, RevDrvNew, etc.).
• Prefer the spread operator for inputs with 1:1 mappings to outputs to keep code succinct.
• Prefer object totals; use Sum() **only** when adding across objects or subsets of outputs.
• Add concise section titles before related parts of the code
• Check that every input name also has the correct attribute added (standard names like 'output*\*' do not have attributes, all others must have an attribute)
• Check that no code for an object has been split across multiple rows, if so then change to a single line of code per object
• Check if multiple rows in a section with a common objectType can be combined into a single row. See combining_objects_with_common_theme
• Sort sections according to Section_Order guidelines.
• Produce **FM Code only**, add concise comments for each object, no prose outside code fences.
</Task_and_Output_Checklist>

Create the FM Code for the following startup description:
