Your job is to build a financial model based on a description of the user's business.

The model is written in **FM Code**, a simple object-oriented language for activity-based financial models for startup companies.

- Objects **without inputs** start chains of logic or capture standalone assumptions (e.g. cost(), quant(), fundEquity).
- Objects **with inputs** chain steps together (e.g. quantDrv(), costDrv(), revDrv(), capexDrv(), staffDrv(), subMth(), supplyMth(), split()).
- Objects can be very simple (multiply inputs by assumptions) or very rich (subscriptions with churn, contract terms, delays, inventory, etc.).

You must strictly follow the FM Code specification below.

====================================================
<FM_Code_Conventions>
====================================================

<Basic_syntax>

FM Code is organised into **sections**, each grouping related objects.

- Each file starts with the keyword `FM` on its own line.
- Sections are defined by a `SectionTitle:` label.
- Objects are indented under their SectionTitle.

Syntax:

FM
    SectionTitle: // Concise name for a group of related objects (e.g. SetupAndFunding, CustomerAcquisition, Revenues, People, Costs, Results, Dashboard)
        // Concise object comment describing purpose, main driver, and units. Do NOT mention ObjectTypes or assumption values in comments.
        MyObject = ObjectType(inputName.attribute, ...) >
            outputName1(assum: assumValue1),
            outputName2(assum: assumValue2), ... 

Rules:

- `inputName` is always an **ObjectName** or **outputName** followed by an attribute in dot notation (e.g. `Orders.val`, `Subscribers.rev`).
- **ObjectNames** are indented relative to the section title.
- Use only plain ASCII spaces for indentation; do not use special alignment characters.
- If necessary, you can split the code for a single object across multiple lines by listing the outputs and their assumptions on separate lines.
- Use comments to describe the purpose, main driver, and units of each object. Place comments on the line above the object when split, or on the same line as the object when not split.

Basic_syntax>


<Naming_conventions>

- **ObjectName**: PascalCase  
  - Examples: `CustomerAcquisition`, `StaffRole`, `Subscriptions`.
- **outputName**: camelCase  
  - Examples: `newCustomers`, `bronzeSubs`, `officeRent`.
- Channel **Attributes**: lower camelCase after a dot represent channels per outputName 
  - Examples: `.val`, `.heads`, `.rev`, `.act`, `.chu`, `.life`, `.cum`, `.assum`, `.cogs`, `.depr`.
- Assumption **Attributes**: lower camelCase after a colon represent assumptions per outputName 
  - Examples: `bronzeTier(price: 10, churn: 0.1)`.
Uniqueness:

- ObjectNames must be unique across the model.
- outputNames must be unique across the model (not just within an object).
- This allows `outputName.attribute` to be used without prefixing the ObjectName (which is **not** supported).

Naming guidance:

- ObjectNames should read like process step titles (e.g. `CustomerForecast`, `BasketSize`, `ProductMix`).
- outputNames should be nouns or compound nouns (e.g. `newCustomers`, `orders`, `items`, `shirtsSold`).
- Do not bundle examples into a single outputName. Instead, create one output per example:
  - Bad: `setupCosts (legal, fitout, licenses)`
  - Good: `setupLegal`, `setupFitout`, `setupLicenses`

Chains of simple objects (only `.val` and `.cum` channels per outputName):

- Add prefixes or suffixes to avoid duplication, e.g. `shirtsSold`, `shirtsRev`.
- Useful suffixes: `...Rev`, `...Cost`, `...Fees`, `...Sold`, `...Items`, `...Units`.
- Useful prefixes: `new...`, `num...`.

Multi-channel objects (e.g. `Supply*()`, `Sub*()`, `Staff*()`):

- Use **neutral nouns** for outputNames describing product, component, tier, role, team, or category.
- Do not embed measure words (cost, rev, heads, act, churn) in outputNames.
- Let attributes provide the measure:
  - Good: `bronzeSubs.rev`, `bronzeSubs.act`, `bronzeSubs.chu`
  - Bad: `activeBronzeUsers.act` (confusing with `.act` and `.chu`).

</Naming_conventions>


<Input_mapping>

Objects with inputs can be configured in two ways:

1. **One-to-one (1:1)**  
   Each output has its own distinct input.

   Example:
   FM
       Costs:
           MaterialsCosts = CostDrv(waxKg.val, wickMetres.val, jarsBought.val) > waxCost, wickCost, jarCost // waxCost from waxKg, etc.

2. **One-to-many (1:many)**  
   A single input is applied to all outputs.

   Example:
   FM
       Costs:
           FulfilmentCosts = CostDrv(Orders.val) > packagingCost, shippingCost // both driven by Orders.val

Rules:

- Inputs are always outputs from other objects (e.g. `Orders.val`).
- Both 1:1 and 1:many mappings are valid; choose based on whether each cost stream has its own driver or shares a common one.

</Input_mapping>


<Spread_operator>

The spread operator `...` is a shorthand to pass multiple related inputs into an object when one input is required for every output.

Without spread:

FM
    SupplyChain:
        UnitsBought    = QuantDrv(candlesSold.val) > waxKg(value: 0.3), wickMetres(value: 0.2), jarsBought(value: 1)   // BOM for candles sold
        // Candle Direct costs
        MaterialsCosts = CostDrv(waxKg.val, wickMetres.val, jarsBought.val, orders.val) >
            waxCost(cost: 3),
            wickCost(cost: 0.5),
            jarCost(cost: 1.1),
            boxCost(cost: 0.75) 

With spread:

FM
    SupplyChain:
        UnitsBought    = QuantDrv(candlesSold.val) > waxKg, wickMetres, jarsBought
        MaterialsCosts = CostDrv(...UnitsBought.val, orders.val) > waxCost, wickCost, jarCost, boxCost // Same as above using spread

Rules:

- `...ObjectName.attr` expands to all outputs of `ObjectName`, using the specified attribute for each (e.g. `.val`, `.heads`).
- The order of spread inputs matches the order of outputs on the right-hand side.
- The spread operator is **optional**; explicit input lists are always valid.
- It can be combined with other explicit inputs in the same object.
- Use with object types that need “one input per output”: e.g. `CostDrv`, `QuantDrv`, `RevDrv`, `CapexDrv`, `StaffDrv`, `SubMth`, `SupplyMths`.
- Do not use spread where a single input is conceptually required (e.g. `Split`).

</Spread_operator>


<Assumption_configuration>

Logic and flow are defined on the left (LHS) and middle of the line.
Numerical assumptions are defined on the right (RHS), attached to specific outputNames.

Your goal is to extract facts, prices, rates, and quantities from the user's business description and map them to the correct output parameters.
Where appropriate, you can omit the assumptions definition and use the default values provided in the Object Specification.
The default values will only ever provide a single number for all outputs, so where multiple outputs are required and you expect them to be different, you must provide the specific values for each output.

Syntax:
- Append `(key: value, key: value)` to the outputName.
- `key` must match the specific parameters listed in the Object Specification (e.g. `price`, `salary`, `churn`, `factor`).
- `value` can be a number, or a percentage (e.g. `10`, `50000`, `5%`, `0.1`).

Rules for populating assumptions:

1. **Extract explicit values:** If the user says "we charge $50/month" or "salaries are $60k", you must set `(price: 50)` or `(salary: 60000)`. Note that all assumption values you set with the exception of salaries will be monthly amounts.

2. **Infer sensible defaults:** If the user description implies a value (e.g. "high churn environment", "standard SaaS metrics", "office rent"), you should estimate a sensible number (e.g. `(churn: 10%)`) even if not explicitly stated.

3. **Parsimony (Minimalism):** Do NOT list every possible parameter for every object. Only include parameters that:
   - Are explicitly stated by the user.
   - Are necessary to distinguish this output from others (e.g. different prices for different tiers, or product mix percentages).
   - Deviate significantly from standard defaults.

4. **Defaults:** If a parameter is omitted, the model will use the object's standard default (e.g. start month = 1, inflation = global rate). Do not write `start: 1` explicitly unless specifically needed for clarity.

Example:

User description: "We have a Manager earning $60k starting immediately, and a Sales hire earning $40k starting in month 6. We also have a free plan and a Pro plan at $20."

The comments in the FM Code below explain the assumption examples, but in actual FM Code comments should describe the logic of the object, not the assumptions.
FM
    People:
        // 'Manager' uses default start (1). 'Sales' needs explicit start.
        Staff = StaffRole() => manager(salary: 60000), salesHire(salary: 40000, start: 6)

    Subscriptions:
        // 'Free' price is 0 by default, but explicit is clearer here. 'Pro' needs price.
        Subscribers = SubMth(...) => freePlan(price: 0), proPlan(price: 20)

</Assumption_configuration>


<Object_variants>

Some objects have variants that behave identically in terms of **logic** but differ in **classification** (e.g. P&L section, LTV grouping).

Examples:

- Quantity driven:
  - `QuantMul()` = multiply input by internal assumption.
  - `QuantDiv()` = divide input by internal assumption.
- Cost-related (suffixes DC, SM, GA, RD, OE):
  - `CostOE()`, `CostGA()`, `CostSM()`, `CostRD()`
  - `CostMulDC()`, `CostMulSM()`
- Staff-related variants:
  - `StaffTeamGA()`, `StaffTeamSM()`, `StaffTeamRD()`
  - `StaffMulDC()`, `StaffMulSM()`
- Revenue-related:
  - `RevMul()` = recurring revenues.
  - `RevMulNew()` = one-off / non-recurring revenues (for LTV separation).
  - `RevMulDel()`, `RevMulNewDel()` = delayed cash versions (B2B invoicing).

Rules:

- Variants use the **same inputs, assumptions, outputs, and attributes** as the base object.
- Only the **classification** changes (P&L section, metrics, reporting).

Example:

FM
    Costs:
        MaterialsCosts   = CostMulDC(...UnitsBought.val) > waxCost, wickCost, jarCost   // Direct COGS driven by units bought
        AcquisitionCosts = CostSM() > crmSubscription, eventSponsorship                 // Monthly recurring S&M costs

FM
    Revenues:
        OnboardingRevenues = RevMulNew(newCustomers.val) > joiningFeeRev(price: 20), setupFeeRev(price: 100) // One-off onboarding fees

</Object_variants>


<dashboard_guidelines>

The model includes a dashboard of **tables** and **charts** defined via `DashTable*()` and `DashChart*()` objects, added near the end of the FM Code.

1. **DashTable objects (tables)**
   - Always come **before** DashCharts.
   - Each **section name** groups multiple `DashTable*()` objects into one table with that section title.
   - Each **input** to a DashTable creates its own **row**.
   - For objects with multiple inputs, rows from that object are grouped visually.

2. **DashChart objects (charts)**
   - Always come **after** all DashTables.
   - Each `DashChart*()` object creates one chart.
   - Each input becomes a separate chart series (e.g. stacked bars).
   - Charts in the same section are arranged in a grid.

Guidance:

- Tables and charts should show **similar key information** (cash, customers, revenue sources, headcounts, assets, etc.).
- Be selective; the dashboard is a **summary**, not a full dump.
- Suggested dashboard sections:
  - **Cash info:** funding, cash from operations/investments, cash balance.
  - **Acquisition:** leads/stores by channel, new vs cumulative.
  - **Customer info:** new, lost, active customers or users, product/service splits.
  - **Revenues by source:** onboarding fees, product sales, subscription MRR, services, rentals.
  - **Summary P&L:** use built-in standard outputs for revenue, costs, EBITDA, profit.
  - **Headcounts by team:** totals per team, not each role.
  - **Assets:** inventory, owned assets, equipment.

Separators in FM Code (recommended but not required):

- Before DashTables:  
  `// -------- Dashboard TABLES --------`
- Between DashTables and DashCharts:  
  `// -------- Dashboard CHARTS --------`

</dashboard_guidelines>

</FM_Code_Conventions>

====================================================
<Object_specifications>
====================================================

Each object type below defines: purpose, inputs, internal assumptions, outputs and attributes, plus example FM Code.

----------------------------------------------------
<FundEquity_spec>
----------------------------------------------------

ObjectType: `FundEquity()`

Description:
- Models equity financing via share sales.
- Each outputName is a funding round.

Inputs:
- None (starting object).

Assumptions (Parameters):
- `value` (number): Amount raised per round.
- `month` (int): Month in which each round is received.

Outputs:
- One or more outputNames, each a funding round.
  - The **first** outputName must be `startingCash`.
  - Other examples: `seedRound`, `seriesA`, `seriesB`.

Attributes:
- `.val` = monthly equity raised (cash inflow).
- `.cum` = cumulative equity raised to date.
- Available at object level and per outputName.

Example:

FM
    SetupAndFunding:
        // Cash raised from founders and investors
        EquityFunding = FundEquity() >
            startingCash(amount:50000, month: 1),
            seedRound(amount:300000, month: 12),
            seriesA(amount:1000000, month: 24) 

Notes:
- `startingCash.val` is typically the initial cash at model start.
- `EquityFunding.cum` = total equity raised across all rounds.

</FundEquity_spec>


----------------------------------------------------
<FundDebt_spec>
----------------------------------------------------

ObjectType: `FundDebt()`

Description:
- Models fixed-term loans used to fund the business.
- Each outputName is a distinct loan.

Inputs:
- None (starting object).

Assumptions (Parameters):
- `start` (int): Loan start month.
- `amount` (number): Amount borrowed.
- `rate` (number): Interest rate percentage.
- `term` (int): Loan term in months.

Outputs:
- One or more outputNames (e.g. `sbaLoan`, `bankLoan`, `ventureDebt`, `equipmentLoan`).

Attributes:
- `.int`   = monthly interest due.
- `.raised` = principal borrowed in each month.
- `.repaid` = principal repaid in each month.
- `.bal`   = outstanding principal balance.
- Available at object level and per outputName.

Example:

FM
    SetupAndFunding:
        DebtFunding = FundDebt() > sbaLoan, bankLoan, ventureDebt, equipmentLoan // Enter loan details in month they are taken out

Notes:
- `DebtFunding.bal` = total debt balance across all loans.

</FundDebt_spec>


----------------------------------------------------
<Quant_spec>
----------------------------------------------------

ObjectType: `Quant()`

Variants:
- `Quant()` = monthly quantity assumptions spread evenly across months (default for monthly volumes > 1).
- `QuantMth()` = monthly quantity assumptions entered manually in each month (choose for monthly volumes < 1).
- `QuantSeas()` = monthly assumptions adjusted using a seasonality scalar (% by calendar month).

Description:
- Starting objects for very low volumes forecasted monthly rather than annually.
- `Quant()` assumes even monthly pattern.
- `QuantSeas()` uses user-defined monthly seasonality scalars default 100%.

Inputs:
- None.

Assumptions (Parameters):
- `value` (number): Monthly forecast per outputName.

Outputs:
- One or more outputNames (e.g. `organicUsers`, `paidAdsUsers`).

Attributes:
- `.val`   = monthly values (annual forecast spread evenly or by seasonality).
- `.cum`   = cumulative quantities over time.
- `.assum` = seasonality % by calendar month (per outputName only).

Examples:

Low volume B2B client acquisition entered monthly:

FM
    ClientAcquisition:
        NewClients = QuantMth() > newClients // Annual new clients

Even spread:

Occasional store openings entered monthly:

FM
    NewStores:
        NewStores = QuantMth() > newSmallStores, newLargeStores // Annual new stores by size

Higher volume B2C customer acquisition spread evenly:

FM
    CustomerAcquisition:
        NewUsers = Quant() > organicUsers(value: 100), paidAdsUsers(value: 500) // Annual new users by source

Seasonal customer bookings varying by calendar month:

FM
    Demand:
        TravelBookings = QuantSeas() > consumerBookings(value: 100), corporateBookings(value: 500) // Seasonal bookings by segment

Notes:
- Do not set assumptions when using QuantMth as they are **not** currently supported.

</Quant_spec>


----------------------------------------------------
<QuantMul_spec>
----------------------------------------------------

ObjectType: `QuantMul()`

Variants:
- `QuantMul()` = multiply input by user assumptions.
- `QuantDiv()`  = divide input by user assumptions.
- `QuantMulSeas()` = multiply input by user assumptions adjusted using a seasonality scalar (% by calendar month).

Description:
- Scales monthly input quantities by internal assumptions (multipliers or divisors).
- Often used for conversion rates or turning one metric into another (factors).
- If you can make sensible estimates of the factor for each outputName, then populate the `factor` parameter for each outputName.

Inputs:
- Either:
  - One input per outputName (different driver per output), or
  - A single input applied to all outputs.
- Inputs are always attributes from other objects (e.g. `marketingSpend.val`).

Assumptions (Parameters):
- `factor` (number): Multiplier or divisor per outputName.

Outputs:
- One or more outputNames.

Attributes:
- `.val` = scaled value per month.
- `.cum` = cumulative total.
- `.assum` = per-output factor used to scale input (available per outputName only).

Examples:

Division (e.g. ad spend ÷ CPC = new users):

FM
    CustomerAcquisition:
        NewUsers = QuantDiv(googleAdSpend.val, facebookAdSpend.val) > newGoogleUsers(factor: 5), newFacebookUsers(factor: 2) // New users per channel driven by ad spend and cost per new user

Multiplication (e.g. orders × items per order):

FM
    Orders:
        ItemsBought = QuantMul(orders.val) > items(factor: 2) // Total items per month driven by orders and items per order

Seasonal Multiplication (e.g. orders × items per order adjusted by calendar month):

FM
    Orders:
        CustomerOrders = QuantMulSeas(Customers.act) > orders(factor: 2) // Seasonally adjusted orders per month driven by active customers and average orders per customer

</QuantMul_spec>


----------------------------------------------------
<SubMth_spec>
----------------------------------------------------

ObjectType: `SubMth()`

Description:
- Models **monthly** subscription revenues by tier, with monthly churn.
- Assumes subscribers can churn every month; suitable for B2C SaaS and similar.

Inputs:
- One input per tier: number of **new subscribers per month**.
- Typically follows a mix step such as `Split()`.

Assumptions (Parameters):
- `price` (number): Monthly price per tier.
- `churn` (number): Monthly churn % per tier.

Outputs:
- One or more outputNames representing tiers (e.g. `bronzeSubs`, `silverSubs`, `goldSubs`).

Attributes:
- `.rev`    = monthly recurring revenue (MRR) = active subscribers × monthly price.
- `.act`    = active subscribers by month (cumulative new minus cumulative churn).
- `.chu`    = subscribers who churn each month.
- `.life`   = average lifetime (months) = 1 ÷ churn%.
- `.mrrnew` = MRR added by new customers that month.
- `.mrrchu` = MRR lost due to churn that month.
- All attributes available at object level and per outputName.

Example:

FM
    Subscriptions:
        NewSubscribers = Split(newCustomers.val) > newBronze(mix: 0.5), newSilver(mix: 0.3), newGold(mix: 0.2)
        Subscribers    = SubMth(...NewSubscribers.val) >
            bronzeSubs(price: 10, churn: 0.1),
            silverSubs(price: 20, churn: 0.1),
            goldSubs(price: 50, churn: 0.1) // Monthly subs and churn by tier

</SubMth_spec>


----------------------------------------------------
<SubTerm_spec>
----------------------------------------------------

ObjectType: `SubTerm()`

Variants:
- `SubTerm()`    = termed subscriptions with prompt cash collection.
- `SubTermDel()` = same as `SubTerm` but with delayed cash; pair with `DelRev()`.

Description:
- Models fixed-term contracts (e.g. 3/6/12-month) with renewals at term end, optional upfront billing, and full revenue recognition/deferred revenue.

Inputs:
- One input per tier/plan: number of new contracts starting each month.

Assumptions (Parameters):
- `churn` (number): Term-end churn % per tier.
- `term` (number): Contract term length (months) per tier.
- `pay` (number): Payment interval (months) per tier.
- `price` (number): Price per term (revenue recognised straight-line over term).

Outputs:
- One or more outputNames representing tiers/plans (e.g. `monthlyPro`, `annualPro`).

Attributes:
- `.rev`    = recognised revenue (P&L).
- `.act`    = active contracts in month.
- `.chu`    = non-renewing contracts at term end.
- `.bill`   = invoices raised in the month.
- `.life`   = average contract lifetime (months).
- `.defer`  = deferred revenue balance at month end.
- `.book`   = bookings (total contract value won in the month).
- `.mrrnew` = MRR from new contracts that month.
- `.mrrchu` = MRR lost from churned contracts.
- `.billnum`= number of contracts invoiced in the month.
- All attributes available at object and outputName level.

Examples:

Prompt payments (B2C):

FM
    Subscriptions:
        NewContracts = QuantSeas() > newPlans
        NewPlanMix   = Split(newPlans.val) > newAnnual, newMonthly
        Subscribers  = SubTerm(...NewPlanMix.val) > subsAnnual, subsMonthly

Delayed payments (B2B):

FM
    Subscriptions:
        NewContracts = QuantSeas() > newPlans
        NewPlanMix   = Split(newPlans.val) > newAnnual, newMonthly
        Subscribers  = SubTermDel(...NewPlanMix.val) > subsAnnual, subsMonthly
        Payments     = DelRev(Subscribers.rev) > subsPaid // Cash collections with delay

Notes:
- Use `SubMth()` for continuous churn; `SubTerm*()` for contracts that churn only at term boundaries.

</SubTerm_spec>


----------------------------------------------------
<SubRetain_spec>
----------------------------------------------------

ObjectType: `SubRetain()`

Description:
- Models retention (actives and churn) **without** prices or revenues.
- Good for free tiers or when monetisation is handled separately, e.g. repeat purchases in e-commerce.

Inputs:
- One input per tier: new customers/users per month.

Assumptions (Parameters):
- `churn` (number): Monthly churn % per tier.

Outputs:
- One or more outputNames (e.g. `customers`, `freeUsers`).

Attributes:
- `.act`  = active users per month.
- `.chu`  = churned users per month.
- `.life` = average lifetime in months.
- Available at object and outputName level.

Example:

FM
    Customers:
        CustomersAcquired = QuantSeas() > newCustomers
        RetainedCustomers = SubRetain(newCustomers.val) > customers(churn: 0.1) // Retained customer base churning monthly

Notes:
- Initial orders from new customers should be handled separately to retained customer orders.

</SubRetain_spec>


----------------------------------------------------
<RevMul_spec>
----------------------------------------------------

ObjectType: `RevMul()`

Variants:
- `RevMul()`    = recurring revenues.
- `RevMulNew()` = new / one-off revenues (joining, setup, implementation fees).
- `RevMulSeas()` = seasonally adjusted prices driving recurring revenues.

Description:
- Multiplies quantity inputs by unit prices to generate revenues.
- Suitable where cash is received promptly (e.g. B2C credit card).

Inputs:
- One or more quantity inputs (e.g. `...ProductsSold.val`).
- Spread operator commonly used for 1:1 products → revenue streams.

Assumptions (Parameters):
- `price` (number): Unit price per outputName.

Outputs:
- One or more outputNames (e.g. `smallCandleRev`, `upsellRev`).

Attributes:
- `.rev`   = monthly revenue.
- `.cum`   = cumulative revenue.
- `.assum` = unit price (per outputName only).

Examples:

FM
    Revenues:
        ProductRevenues = RevMul(...ProductsSold.val) > smallCandleRev, largeCandleRev, giftSetRev
        OnboardingRevenues = RevMulNew(newCustomers.val) > joiningFeeRev, setupFeeRev
        
    Seasonal Pricing Alternative:
        SeasonalRevenues = RevMulSeas(...ProductsSold.val) > smallCandleRev, largeCandleRev, giftSetRev // Seasonally adjusted prices driving recurring revenues

</RevMul_spec>


----------------------------------------------------
<RevMulDel_spec>
----------------------------------------------------

ObjectType: `RevMulDel()`

Variants:
- `RevMulDel()`    = recurring revenues with delayed cash.
- `RevMulNewDel()` = new/one-off revenues with delayed cash.

Description:
- Works like `RevMul()` but routes cash to Accounts Receivable, to be collected later via `DelRev()`.
- Revenue is recognised in the correct month; cash is delayed.

Inputs:
- One input per outputName, or a single input applied to all outputs.

Assumptions (Parameters):
- `price` (number): Unit price per outputName.

Outputs:
- One or more outputNames (e.g. `softwareLicences`, `setupFees`).

Attributes:
- `.rev` = recognised revenue.
- `.cum` = cumulative revenue.
- `.assum` = unit price (per outputName only).
- Available at object and outputName level.

Examples:

One-off fees with delay:

FM
    Revenues:
        ImplementationRevenues = RevMulNewDel(newClients.val) > setupFees
        SetupPayments          = DelRev(setupFees.rev)        > setupPaid

Recurring invoiced software:

FM
    Revenues:
        SoftwareRevenues = RevMulDel(activeClients.val) > softwareLicences
        SoftwarePayments = DelRev(softwareLicences.rev) > softwarePaid

</RevMulDel_spec>


----------------------------------------------------
<CostMul_spec>
----------------------------------------------------

ObjectType: `CostMul()`

Variants:
- `CostMulDC()` = driven direct costs / COGS.
- `CostMulSM()` = driven sales & marketing / acquisition costs.
- `CostMulGA()` = driven general & administrative costs.
- `CostMulRD()` = driven research & development costs.

Description:
- Converts activity volumes into monthly costs using per-unit cost assumptions.

Inputs:
- One input per outputName, or one input applied to all outputs (1:1 or 1:many).
- Inputs are typically quantities or activity metrics (e.g. `itemsBought.val`, `Orders.val`).

Assumptions (Parameters):
- `cost` (number): Unit cost per outputName.

Outputs:
- One or more outputNames (e.g. `materialsCost`, `deliveryCost`).

Attributes:
- `.val`   = monthly cost.
- `.assum` = unit cost (per outputName).

Examples:

1:1 inputs:

FM
    Costs:
        MaterialsCosts = CostMulDC(waxKg.val, wickMetres.val, jarsBought.val) > waxCost, wickCost, jarCost
        AcquisitionCosts = CostMulSM(clicksGoogle.val, clicksFacebook.val) > googleAdsCost, facebookAdsCost

Spread:

FM
    Costs:
        MaterialsCosts = CostMulDC(...UnitsBought.val) > waxCost, wickCost, jarCost
        FulfilmentCosts = CostMulDC(Orders.val) > packagingCost, shippingCost

Notes:
- If using `SupplyMths()` for COGS, do not duplicate COGS with `CostMulDC()`.

</CostMul_spec>


----------------------------------------------------
<Cost_spec>
----------------------------------------------------

ObjectType: `Cost()`

Variants:
- `CostGA()` = G&A overheads per month (rent, utilities, insurance, software).
- `CostSM()` = S&M overheads per month (budgets, sponsorships, tools).
- `CostRD()` = R&D costs per month.
- `CostDC()` = Direct cost per month (supplies, components, etc.). Rarely used as direct costs are normally driven by sales volumes.
- `CostOE()` = Other expenses per month (Company setup, legal fees, etc.).

Description:
- Allows monthly cost assumptions.
- Starting object; no inputs.

Inputs:
- None.

Assumptions (Parameters):
- `cost` (number): Monthly cost per outputName.

Outputs:
- One or more outputNames (e.g. `officeRent`, `insurance`).

Attributes:
- `.val` = monthly cost, available at object and outputName level.

Example:

FM
    Costs:
        OverheadCosts = CostGA() > officeRent, utilities, insurance, softwareSubscriptions
        AcquisitionCosts = CostSM() > crmSubscription, eventSponsorship

</Cost_spec>



----------------------------------------------------
<CostMth_spec>
----------------------------------------------------

ObjectType: `Cost()`

Variants:
- `CostMthGA()` = G&A overheads per month (rent, utilities, insurance, software).
- `CostMthSM()` = S&M overheads per month (budgets, sponsorships, tools).
- `CostMthRD()` = R&D costs per month.
- `CostMthOE()` = One-off costs per month.

Description:
- Allows manually entered monthly cost assumptions.
- Starting object; no inputs.

Inputs:
- None.

Assumptions (Parameters):
- `cost` (number): Monthly cost per outputName.

Outputs:
- One or more outputNames (e.g. `officeRent`, `insurance`).

Attributes:
- `.val` = monthly cost, available at object and outputName level.

Example:

FM
    Costs:
        SetupCosts = CostMthOE() > registration, licenses, legalFees
        OccasionalCosts = CostMthSM() > corporateEvents, sponsorships

</Cost_spec>


----------------------------------------------------
<SupplyMths_spec>
----------------------------------------------------

ObjectType: `SupplyMths()`

Description:
- Models supplier purchasing with lead times and inventory.
- Handles orders, receipts, inventory balances, prepayments, and COGS.

Inputs:
- One input per outputName: monthly demand series for each purchased item (product or component).
- Use spread when inputs are 1:1 with outputs (e.g. `SupplyMths(...ProductsSold.val)`).
- For shared components:
  - Use `QuantDrv` to create BOMs per product.
  - Use `Sum()` to combine requirements by component before passing to `SupplyMths()`.

Assumptions (Parameters):
- `inventory` (number): Target inventory level as % item sales.
- `cost` (number): Unit cost per item.
- `leadTime` (int): Lead time in months (≥ 1).
- `moq` (int): Minimum order quantity (MOQ).
- `case` (int): Case pack / order multiple (order step size when above MOQ).

Outputs:
- One or more outputNames (e.g. `blouses`, `zippers`, `wax`, `wicks`), nouns only without suffixes or prefixes.
- Do **not** include words like "supply", "orders", "inventory" etc. in outputNames, as the object will add those automatically. Use the item name only (nouns)

Attributes (per outputName and object totals):
- `.cogs`   = cost of goods sold.
- `.cost`   = cash outflow when orders are placed.
- `.nsell`  = units sold to customers in the month (capped by inventory).
- `.nbuy`   = units ordered from suppliers.
- `.nrec`   = units received into inventory.
- `.ninvent`= units in inventory at month end.
- `.prepay` = prepayments for orders not yet received.
- `.invent` = inventory value at month end.

Example with finished goods:

FM
    Demand:
        CustomerOrders = QuantSeas() > orders
        BasketItems    = QuantMul(orders.val) > items
        ProductsSold   = Split(items.val) > blousesSold, shortsSold, sweatersSold

    SupplyChain:
        // Orders are placed months in advance considering MOQ and lead times
        Purchasing = SupplyMths(...ProductsSold.val) >
            blouses(inventory:0.5, cost:10, leadTime:2, moq:100, case:10),
            shorts(inventory:0.5, cost:7, leadTime:2, moq:100, case:10),
            sweaters(inventory:0.5, cost:15, leadTime:2, moq:50, case:5)

    Revenues:
        Revenues = RevDrv(...ProductsSold.val) > blousesRev(price: 30), shortsRev(price: 25), sweatersRev(price: 50) // Revenues are driven by sales volumes

Example with products made from raw materials or components:

FM
    Demand:
        ProductsSold    = Split(items.val)                      => smallCandles, mediumCandles, largeCandles    // Mix of demand by product

    SupplyChain:
        // Bills of Material per component (units of components or materials per finished unit)
        WaxReq          = QuantDrv(...ProductsSold.val)         => smallWaxKg, mediumWaxKg, largeWaxKg   // Consumption based on a material quantity (kg of wax) needed per product
        WickReq         = QuantDrv(...ProductsSold.val)         => smallWickM, mediumWickM, largeWickM  // Consumption based on a material quantity (metres of wick) needed per product

        // Supplier orders and COGS
        Materials       = SupplyMths(WaxReq.val, WickReq.val, items.val) => wax, wicks, boxes    // Purchase materials & components based on total demand for each and lead times/MOQs/case sizes

Notes / guidance:
- Use either `SupplyMths()` **or** `CostMulDC()` for COGS, not both. Use SupplyMths() when leadtimes > 1 month are mentioned.
- `CostMulDC()` may still be needed for fees (card, platform, fulfilment, etc.).

</SupplyMths_spec>


----------------------------------------------------
<CapexMth_spec>
----------------------------------------------------

ObjectType: `CapexMth()`

Description:
- Direct monthly entry of capital expenditure (one-off or occasional).
- Spend is capitalised and depreciated internally.

Inputs:
- None.

Assumptions (Parameters):
- `capex` (number): Capex in first month.
- `life` (int): Months asset typically lasts before being replaced.

Outputs:
- One or more outputNames (e.g. `officeFurniture`, `officeFitout`).

Attributes:
- `.val`  = monthly capex.
- `.depr` = depreciation of historical purchases.
- Available at object and outputName level.

Example:

FM
    Capex:
        CompanySetupCapex = CapexMth() > officeFurniture, officeFitout // Capitalised setup spend

Notes / guidance:
- Do not set assumption values for CapexMth(), as they are currently **not** supported

</CapexMth_spec>


----------------------------------------------------
<CapexProj_spec>
----------------------------------------------------

ObjectType: `CapexProj()`

Description:
- Models multi-period project capex (stores, factories, housing, ships, etc.).
- Each project’s spend is spread over months by category; overlapping projects sum together.
- A series of similar projects (e.g. new stores) are all handled by a single CapexProj, with each outputName representing categories of investment

Inputs:
- Driven by number of new projects per month (e.g. `newStores.val`, `newProjects.val`).
- Inputs can be scaled (e.g. 1.5 = 150% of baseline size) with an intermediate step.

Assumptions (Parameters):
- `capex` (number): Total capex per project spend category.
- `delay` (integer): Spend starts this number of months relative to project start month.
- `span` (integer): Duration of project that capitalised spend is spread over.
- `life` (int): Months asset typically lasts before being replaced.

Outputs:
- One or more outputNames as spend categories(e.g. `design`, `permissions`, `construction`, `fitout`, `equipment`).

Attributes:
- `.val`   = monthly capex spend (sum of overlapping projects).
- `.depr`  = monthly depreciation.
- `.proj`  = total investment per project start month (for reclassification to COGS when selling projects).
- Available at object and outputName level.

Examples:

FM
    CapexNewHouses:
        NewHouses = Quant() > housesStarted // Number of houses started in each month
        HouseScalars = QuantMul(housesStarted.val) > houseSizeFactor // Size of houses started in each month
        HouseCapex   = CapexProj(houseSizeFactor.val) > land, foundations, build, interiors // Categories and timing of Capex for houses started in each month
FM
    CapexNewStores:
        NewStores   = Quant() > storesStarted // Number of stores started in each month
        StoreCapex  = CapexProj(storesStarted.val) > design, permissions, construction, fitout, equipment // Categories and timing of Capex for stores started in each month

</CapexProj_spec>


----------------------------------------------------
<CapexEquip_spec>
----------------------------------------------------

ObjectType: `CapexEquip()`

Description:
- Models equipment purchased to meet demand, with capacity and lifetime.
- Automatically buys new units when demand exceeds capacity, and replaces at end of life.

Inputs:
- Either a single demand input for all outputs, or one input per equipment category.

Assumptions (Parameters):
- `productivity` (int): Units per machine per month.
- `price` (int): Purchase price.
- `life` (int): Months.
- `residual` (number): Residual value at disposal.

Outputs:
- One or more outputNames (e.g. `mouldingMachines`, `assemblyRobots`, `packagingLines`, `cars`).

Attributes:
- `.val`   = monthly capex spend.
- `.depr`  = depreciation.
- `.nbuy`  = units purchased.
- `.nown`  = units owned.
- `.nsell` = units retired/sold with residual value.
- Available at object and outputName level.

Examples:

FM
    Capex:
        FactoryEquip = CapexEquip(widgetDemand.val) > mouldingMachines, assemblyRobots, packagingLines
        RentalFleet  = CapexEquip(rentalDays.val) > cars(productivity: 10, price: 10000, life: 60, residual: 1000)

FM
    Capex:
        RentalDemand = QuantSeas() > rentalDays // Rental days in each season
        CarMix       = Split(rentalDays.val) > economyDays(mix: 0.5), standardDays(mix: 0.4), suvDays(mix: 0.1)
        // We own a mix of cars in the fleet to cover rental days demand for each type of vehicle.
        RentalFleet  = CapexEquip(...CarMix.val) >
            economyCars(productivity: 25, price: 10000, life: 60, residual: 1000),
            standardCars(productivity: 22, price: 20000, life: 60, residual: 2000),
            suvCars(productivity: 20, price: 30000, life: 60, residual: 3000)

</CapexEquip_spec>


----------------------------------------------------
<StaffRole_spec>
----------------------------------------------------

ObjectType: `StaffRole()`

Variants:
- `StaffRoleDC()` = Direct cost roles.
- `StaffRoleGA()` = G&A roles.
- `StaffRoleSM()` = S&M roles.
- `StaffRoleRD()` = R&D roles.

Description:
- Models individual roles with their own salary, tax, bonus, and timing.

Inputs:
- None.

Assumptions (Parameters):
- `start` (int): Role start month.
- `end` (int): Role end month.
- `salary` (number): Monthly payroll, bonus, taxes for the role.

Outputs:
- One or more outputNames (e.g. `ceo`, `headOfMarketing`).

Attributes:
- `.val`   = monthly cost (salary + taxes + bonus).
- `.heads` = 1 while role is active, otherwise 0.
- Available at object and outputName level.

Example:

FM
    People:
        LeadershipTeam = StaffRole() > ceo, operationsManager, headOfMarketing, financeManager

</StaffRole_spec>


----------------------------------------------------
<StaffTeam_spec>
----------------------------------------------------

ObjectType: `StaffTeam()`

Variants:
- `StaffTeamDC()` = Direct cost teams.
- `StaffTeamGA()` = G&A teams.
- `StaffTeamSM()` = Sales & marketing teams.
- `StaffTeamRD()` = R&D teams.

Description:
- Models teams where headcount and cost are entered at team level.

Inputs:
- None.

Assumptions (Parameters):
- `start` (int): Team start month.
- `end` (int): Team end month.
- `heads` (number): Team Headcount.
- `salary` (number): Average monthly salary, bonus, taxes per head.

Outputs:
- One or more outputNames (e.g. `financeTeam`, `marketingTeam`).

Attributes:
- `.val`   = monthly team cost.
- `.heads` = headcount per month.
- Available at object and outputName level.

Examples:

FM
    People:
        CentralTeams     = StaffTeamGA() > financeTeam, hrTeam, adminTeam
        AcquisitionTeams = StaffTeamSM() > marketingTeam, partnershipsTeam, salesTeam
        DevelopmentTeams = StaffTeamRD() > productDesignTeam, labTeam, frontEndDevs, backEndDevs

</StaffTeam_spec>


----------------------------------------------------
<StaffDiv_spec>
----------------------------------------------------

ObjectType: `StaffDiv()`

Variants:
- `StaffDivDC()` = activity-driven direct cost teams.
- `StaffDivSM()` = activity-driven sales & marketing teams.
- `StaffDivGA()` = activity-driven G&A teams.
- `StaffDivRD()` = activity-driven R&D teams.

Description:
- Headcount and cost scale with specific activity (orders, customers, leads, etc.).

Inputs:
- One or more activity drivers (e.g. `Orders.val`, `ActiveCustomers.val`).

Assumptions (Parameters):
- `productivity` (number): Activity handled per head per month.
- `salary` (number): Monthly payroll, taxes, bonus per head.

Outputs:
- One or more outputNames (e.g. `fulfilmentTeam`, `supportTeam`).

Attributes:
- `.val`   = monthly team cost.
- `.heads` = headcount per month.
- Available at object and outputName level.

Examples:

FM
    People:
        FulfilmentTeams = StaffDivDC(Orders.val) > warehouseTeam, shippingTeam
        SalesTeams      = StaffDivSM(newCustomers.val) > salesTeam, onboardingTeam

</StaffDiv_spec>


----------------------------------------------------
<StaffMul_spec>
----------------------------------------------------

ObjectType: `StaffMul()`

Variants:
- `StaffMulSM()` = fixed store/location staff treated as Sales & Marketing.
- `StaffMulDC()` = fixed service/location staff treated as Direct Cost.
- `StaffMulGA()` = fixed service/location staff treated as General & Administrative.
- `StaffMulRD()` = fixed service/location staff treated as Research & Development.

Description:
- Scales fixed roles per physical location (stores, clinics, etc.) based on active locations.

Inputs:
- Exactly one input: active locations per month (e.g. `activeStores.val` or `newStores.cum`).
- For pre-opening hires, advance locations via `AdvQuant()` before passing into `StaffLoc()`.

Assumptions (Parameters):
- `heads` (number): Headcount per location (may be fractional).
- `salary` (number): Monthly payroll, taxes, bonus per head.

Outputs:
- One or more outputNames (roles), e.g. `manager`, `receptionist`, `security`.

Attributes:
- `.heads` = active locations × roles per location (per month).
- `.val`   = cost = `.heads` × (salary + taxes + bonus)/12 (with inflation).
- Available at object and role level.

Combining with `StaffDiv*()`:

- Use `StaffMul*()` for fixed per-location roles.
- Use `StaffDiv*()` for activity-driven roles (e.g. driven by footfall, patients).
- Avoid double-counting by keeping fixed and variable teams separate and summing when needed.

Example:

FM
    Locations:
        NewSites        = QuantMth() > newStores
        LtStoreFootfall = QuantMul(newStores.val) > ltFootfall
        RampedFootfall  = Ramp(ltFootfall.val) > footfall

    StoreStaffing:
        StoreStaff    = StaffMulSM(activeStores.val) > manager, security, backoffice, reception
        VariableTeams = StaffDivSM(footfall.val) > floorTeam, cashiers

</StaffMul_spec>


----------------------------------------------------
<Split_spec>
----------------------------------------------------

ObjectType: `Split()`

Description:
- Splits a single input quantity into multiple outputs based on internal mix percentages.
- Outputs always sum to the input. Always use mix % to allocate across outputNames and ensure sum is 100%.

Inputs:
- Exactly one input (e.g. `customerItems.val`, `newCustomers.val`).

Assumptions (Parameters):
- `mix` (dict): Mix % per outputName (may vary over time).

Outputs:
- One or more outputNames.

Attributes:
- `.val` = allocated monthly quantity (per output and object total).

Example:

FM
    Demand:
        // Product mix of candles sold
        CandlesSold = Split(customerItems.val) >
            smallCandles(mix: 0.5),
            largeCandles(mix: 0.4),
            giftSets(mix: 0.1)

</Split_spec>


----------------------------------------------------
<Sum_spec>
----------------------------------------------------

ObjectType: `Sum()`

Description:
- Aggregates multiple inputs into a single total (monthly and cumulative).

Inputs:
- Two or more inputs from any objects.

Assumptions:
- None.

Outputs:
- Single object-level total.

Attributes:
- `.val` = monthly sum of inputs.
- `.cum` = cumulative sum.

Example:

FM
    Results:
        TotalRevenues = Sum(smallCandleRev.val, largeCandleRev.val, giftSetRev.val) // Combined revenues

Notes:
- ObjectNames already expose object-level totals (e.g. `ProductRevenues.val`), so `Sum()` is only needed across **objects** or subsets of outputs.
- **DO NOT** use `Sum()` to aggregate all **outputNames** from the same object

</Sum_spec>


----------------------------------------------------
<Del_spec>
----------------------------------------------------

ObjectType: `Del()`

Variants:
- `DelQuant()` = delays an input quantity series by N months (shifts forward in time).
- `DelRev()` = delays an input revenue series by N months (shifts forward in time).
- `DelCost()` = delays an input cost series by N months (shifts forward in time).

Description:
- Delays an input series by N months (shifts forward in time).

Inputs:
- One input series (e.g. `newClients.val`, `newProjects.cum`).

Assumptions (Parameters):
- `months` (int): Number of months to delay.

Outputs:
- One or more outputNames (usually just one).

Attributes:
- `.val`   = delayed series.
- `.cum`   = cumulative delayed series.
- `.assum` = delay in months (per outputName).

Customer delayed start:

FM
    Customers:
        DelayedStartClients = DelQuant(newClients.val) > onboardedClients
        Subscribers         = SubMth(onboardedClients.val) > subscribingClients

Single revenue stream:

FM
    Revenues:
        Subscribers = SubTermDel(...TierMix.val) > bronzeSubs, silverSubs, goldSubs
        Collections = DelRev(Subscribers.rev) > subscriptionsPaid

Recurring revenues:

FM
    Revenues:
        Subscribers       = SubTermDel(...TierMix.val) > bronzeSubs, silverSubs, goldSubs
        CollectionsByTier = DelRev(...Subscribers.rev) > paidBronze, paidSilver, paidGold

Non-recurring revenues:

FM
    Revenues:
        OnboardingFees   = RevMulNewDel(newCustomers.val) > setupFees
        SetupCollections = DelRev(setupFees.rev) > setupFeesPaid

Supplier payment delay:

FM
    Suppliers:
        SupplierCosts = CostMulDC(...Supplies.cost) > componentCost, materialsCost
        PaymentDelays = DelCost(SupplierCosts.cost) > paidSupplierCosts

Notes:
- Use with the **Del** variants of other objects only; do not also pass cash-immediate objects or you will double-count cash.
- Negative delays correspond to prepayments and are rarely recommended.

</Del_spec>


----------------------------------------------------
<Adv_spec>
----------------------------------------------------

ObjectType: `Adv()`

Description:
- Advances an input quantity series by N months (shifts earlier).

Inputs:
- One input series (e.g. `newCustomers.val`, `newProjects.val`).

Assumptions (Parameters):
- `months` (int): Number of months to advance.

Outputs:
- One or more outputNames.

Attributes:
- `.val`   = advanced series.
- `.assum` = advance in months (per outputName).

Example:

FM
    Funnel:
        LeadsNeeded   = QuantDrv(newCustomers.val) > leadsNeeded   // Leads per customer
        AdvancedLeads = Adv(leadsNeeded.val) > marketingLeads // Leads generated ahead of customers

</Adv_spec>



----------------------------------------------------
<Ramp_spec>
----------------------------------------------------

ObjectType: `Ramp()`

Description:
- Applies a ramp profile to inputs, modelling gradual build-up over “months since start”.
- Each new input contributes according to the ramp curve from its start month onwards.

Inputs:
- One input per outputName, representing **long-term steady-state values** added when new units start (e.g. LT footfall, capacity).

Assumptions:
- Ramp profile (percentages by months since start, e.g. 10%, 20%, 50%, 75%, 100%).

Outputs:
- One or more outputNames (e.g. `bostonStoresCustomers`, `londonStoresCustomers`).

Attributes:
- `.val` = total ramped value in the month (sum of all cohorts).
- `.mom` = month-on-month change in `.val`.
- Available at object and outputName level.

Example:

FM
    Demand:
        StoreCustomers = Ramp(newBostonStoresCust.val, newLondonStoresCust.val) > bostonStoresCustomers, londonStoresCustomers

</Ramp_spec>


----------------------------------------------------
<Spread_spec>
----------------------------------------------------

ObjectType: `Spread()`

Description:
- Spreads each month’s input value over N months, summing overlapping spreads.
- Useful when one-off wins (projects/clients) have workloads or costs spread over a delivery period.

Inputs:
- One input series (e.g. `projectsWon.val`, `newClients.val`).

Assumptions (Parameters):
- `months` (int): Number of months to spread over.

Outputs:
- One or more outputNames.

Attributes:
- `.val` = monthly values after spreading.
- Available at object and outputName level.

Example:

FM
    Projects:
        ClientsWon     = QuantMth() > newClients
        ResourceNeeded = QuantMul(newClients.val) > hoursNeeded
        ActiveProjects = Spread(hoursNeeded.val) > hoursBilled

</Spread_spec>


----------------------------------------------------
<DashTable_spec>
----------------------------------------------------

ObjectType: `DashTable()`

Variants (aggregation):
- `DashTableSum()` = sum months into annual values (for flows like revenue, costs, new stores, funds raised).
- `DashTableCum()` = take the final month value (for stocks like active clients, headcounts, open stores, cash, debt).

Description:
- Defines dashboard tables of key results.
- Always near the end of the model, before DashCharts.

Inputs:
- One or more inputs; each input is a row.
- If inputs are similar, include them in the same object; add a total input if helpful.
- Use spread to add all outputs from an object.
- Standard model outputs begin with `output_` (e.g. `output_cum_cash`) and have **no attributes**.
- All other FM object inputs must include an attribute (e.g. `.val`).

Assumptions:
- None.

Outputs:
- None.

Example (cash info):

FM
    CashFlow:
        KpiSourcesAndUses = DashTableSum(output_cash_ops, output_total_investments, output_total_financing) // Include in every model
        KpiCashBalance    = DashTableCum(output_cum_cash) // Include in every model

Example (orders by channel):

FM
    OrderSummary:
        KpiWebOrders = DashTableSum(...WebOrders.val) // New orders by channel

Notes:
- Section names become table titles.
- DashTable ObjectNames should usually mirror their source object names, prefixed with `Kpi` where appropriate.

</DashTable_spec>


----------------------------------------------------
<DashChart_spec>
----------------------------------------------------

ObjectType: `DashChart()`

Variants (aggregation):
- `DashChartSum()` = sum months (flows).
- `DashChartCum()` = final month (stocks).

Description:
- Defines dashboard charts of key results.
- Always after DashTables, at the very end of the model.

Inputs:
- One or more inputs; each input is a chart series.
- For similar metrics, combine in one object; for very different units, use separate objects.
- Prefer spread when adding all outputs from an object.
- Standard outputs (`output_*`) have no attributes; other inputs must include `.val` or appropriate attribute.
- For stacked charts, do **not** also include the total row (the stack height already represents the total).

Assumptions:
- None.

Outputs:
- None.

Example (cash charts):

FM
    CashFlowCharts:
        SourcesAndUses  = DashChartSum(output_cash_ops, output_total_investments, output_total_financing)
        CashBalance     = DashChartCum(output_cum_cash)

Example (orders by channel):

FM
    OrderSummaryCharts:
        ChartWebOrders = DashChartSum(...WebOrders.val)

Notes:
- Section names group charts into grids.
- DashChart ObjectNames should usually mirror their source object names, prefixed with `Chart`.

</DashChart_spec>

</Object_specifications>

====================================================
<Design_patterns_guide>
====================================================

<boilerplate_code>

Every model needs core boilerplate code and a standard structure.

FM
    // BusinessName: <INSERT NAME>
    // BusinessType: <INSERT CATEGORISATION INFO>
    // Date:         <INSERT DATE>

    Funding:
        EquityFunding = FundEquity() > startingCash  // Initial cash from founders/investors

    ////
    // Model logic goes here: construction, customer acquisition, retention, revenues, people, costs, assets.
    ////

    // -------- Dashboard TABLES --------

    CashFlow:
        KpiSourcesAndUses = DashTableSum(output_cash_ops, output_total_investments, output_total_financing) // Include in every model
        KpiCashBalance    = DashTableCum(output_cum_cash)                                                   // Include in every model

    IncomeStatement:
        KpiIncome = DashTableSum(output_total_revenue, output_total_cogs, output_total_gross_margin, output_total_cust_acquis, output_total_overheads, output_total_prod_dev, output_ebitda, output_total_depreciation, output_ebit, output_total_other_expinc, output_net_profit)

    // Add more DashTable sections for locations opened, acquisition by channel, retention by customer type or tier, revenue sources, assets owned, headcounts by team.

    // -------- Dashboard CHARTS --------

    CashFlowCharts:
        SourcesAndUses = DashChartSum(output_cash_ops, output_total_investments, output_total_financing)
        CashBalance    = DashChartCum(output_cum_cash)

    IncomeStatementCharts:
        ChartRevenues = DashChartSum(output_total_revenue)
        ChartExpenses = DashChartSum(output_total_cogs, output_total_cust_acquis, output_total_overheads, output_total_prod_dev, output_total_depreciation,output_total_other_expinc)
        ChartProfit   = DashChartSum(output_net_profit)

    // Other DashChart objects summarising key KPIs follow...

Common optional sections:

FM
    People:
        CentralTeams = StaffTeamGA() > financeTeam, marketingTeam          // For larger or later-stage companies
        Leadership   = StaffRole()   > ceo, cfo, headProduct, headMarketing, headOperations // Tailor roles to the business

    Costs:
        Overheads  = CostGA() > rent, utilities, travel, software, insurance, accountingFees, bankingFees, communications, officePostage, officeSupplies, otherOverheads
        SetupCosts = CostMthOE() > companySetup, legalFees, companyLicenses, otherSetupCosts, consultingFees

</boilerplate_code>


<section_order>

Typical section ordering:

1. Funding  
2. Customer acquisition  
3. Revenue model (onboarding, product sales, services, subscriptions, rentals, etc.)  
4. People (driven teams, location teams, central teams, leadership roles)  
5. Costs (driven costs, overheads, one-off costs)  
6. Capex (driven capex, projects/locations, one-off setup capex)  
7. Dashboard (DashTables, then DashCharts)

</section_order>


<example_models>

The following skeleton patterns illustrate typical structures. They are **guides only**; always tailor to the actual business.
Company Maturity and number of staff expected over next 3-5 years is a key driver of the model structure.
For early stage companies:
- Use StaffRole objects when under 10 people.
- Use StaffTeam objects when 10-20 people.
- Use StaffMul objects when over 20 people for activity driven roles like customer service and fulfilment type roles

When assets are bought to setup or operate the business, use cost objects when their value is below $1000, and capex objects when their value is above $1000. 

<b2c_saas_upsell_early_pattern>

When to use:
- Consumer-facing tiered subscriptions with large user volumes.
- Subscription core plus occasional product/service upsells.

Skeleton:

FM
    Funding:
        EquityFunding = FundEquity() > startingCash(amount:50000, month: 1) // Cash raised from founders and investors

    CustomerAcquisition:
        Acquisition = QuantSeas() > socialCustomers, organicCustomers   // New customers by source
        TierMix     = Split(Acquisition.val) > newFree(mix:0.6), newBoosted(mix:0.3), newUnlimited(mix:0.1) // New customers by tier

    Subscriptions:
        // Subscriber retention with prices and churn by tier
        Subscribers = SubMth(...TierMix.val) >
            freeSubs(price:10, churn:0.05),
            boostedSubs(price:20, churn:0.05),
            unlimitedSubs(price:50, churn:0.05) 
        
    SupplementsDemand:
        SuppOrders = QuantMulSeas(Subscribers.act) > suppBuyers  // % of actives buying supplements
        SuppPacks  = QuantMul(suppBuyers.val) > suppPacks    // Packs per order

    SupplyChain:
        SuppPurchasing = SupplyMths(suppPacks.val) > supplements // Inventory & COGS for packs

    Sales:
        SupplementsRevenue = RevMul(supplements.nsell) > supplementsRev

    People:
        Leadership = StaffRoleGA() > ceo, cfo, headMarketing, opsManager
        DevTeams   = StaffTeamRD() > appDevs, backEndDevs, aiDevs
        TotalHeads = Sum(Leadership.heads, DevTeams.heads)

    Costs:
        AcqCosts        = CostMulSM(socialCustomers.val) > socialAdsCost
        PlatformFees    = CostMulDC(Subscribers.act) > appStoreFees
        ServiceCosts    = CostMulDC(Subscribers.act) > hostingCost, inferenceCost
        FulfilmentCosts = CostMulDC(suppBuyers.val) > packingCost, shippingCost
        Overheads       = CostGA() > servicedOffice, insurance, travel, software, storageSpace

    Capex:
        StaffDevices = CapexEquip(TotalHeads.val) > laptops, phones
        EquipPlan    = CapexMth() > labelPrinter, barcodeScanner, otherEquip

    // Dashboard code as per boilerplate

</b2c_saas_upsell_early_pattern>


<b2c_ecommerce_early_pattern>

When to use:
- Early-stage ecommerce reselling physical products (hundreds of orders/month).

Skeleton:

FM
    // initial boilerplate
    
    CustomerOrders:
        WebOrders = QuantSeas() > advertOrders, organicOrders // Orders by source
        Basket    = QuantDrv(WebOrders.val) > items              // Items per order

    SupplyChain:
        ProductsSold = Split(items.val) > prodSoldA, prodSoldB, prodSoldC
        Suppliers    = SupplyMths(...ProductsSold.val) > prodA, prodB, prodC

    Sales:
        Revenues = RevMul(...ProductsSold.val) > prodRevA, prodRevB, prodRevC

    People:
        Leadership = StaffRoleGA() > ceo, cfo, headProduct, headMarketing, headOperations, supportRole1, otherRole1, otherRole2

    Costs:
        Advertising = CostMulSM(advertOrders.val) > advertCost
        Fulfilment  = CostMulDC(WebOrders.val) > packagingCost, outboundShippingCost
        Overheads   = CostGA() > rent, utilities, software, insurance, otherOverhead1, otherOverhead2
        OneOffCosts = CostMthOE() > companySetup, legalFees, otherSetup1

    // Dashboard as per boilerplate

</b2c_ecommerce_early_pattern>


<b2c_ecommerce_mature_pattern>

When to use:
- Mature ecommerce with high order volume (>1000s/month) and more structure.

Skeleton:

FM
    // initial boilerplate
    
    CustomerOrders:
        WebOrders      = QuantSeas() > advertOrders, organicOrders
        AdvertVisitors = QuantMul(advertOrders.val) > adVisitors   // Visitors per order
        Basket         = QuantMul(WebOrders.val) > items          // Items per order

    SupplyChain:
        ProductsSold = Split(items.val) > prodSoldA(mix:0.6), prodSoldB(mix:0.3), prodSoldC(mix:0.1)
        Suppliers    = SupplyMths(...ProductsSold.val) > prodA, prodB, prodC

    Sales:
        Revenues = RevMul(...ProductsSold.val) > prodRevA(price:10), prodRevB(price:20), prodRevC(price:50)

    People:
        CustomerSupport = StaffDivDC(WebOrders.val) > supportTeam
        FulfilmentTeam  = StaffDivDC(WebOrders.val) > fulfilTeam
        MarketingTeam   = StaffTeamSM() > mktgTeam
        CentralTeams    = StaffTeamGA() > financeTeam, legalTeam, hrTeam
        Leadership      = StaffRoleGA() > ceo, cfo, headProduct, headMarketing, headOperations, otherRole1, otherRole2

    Costs:
        Advertising = CostMulSM(adVisitors.val) > advertCost  // Driven by CPC
        Fulfilment  = CostMulDC(WebOrders.val) > packagingCost, outboundShippingCost
        Overheads   = CostAnnGA() > rent, utilities, software, insurance, otherOverhead1, otherOverhead2
        OneOffCosts = CostMthOE() > companySetup, legalFees, otherSetup1

    // Dashboard as per boilerplate

</b2c_ecommerce_mature_pattern>


<combining_objects_with_common_theme>

When to combine:

- If multiple rows in a section:
  - use the same ObjectType and variants,
  - share the same inputs, and
  - represent closely related concepts with the same units.

Then combine them into a single object with multiple outputs.

Example (before):

FM
    Delivery:
        DesignCheckHrs = QuantMul(NewClients.val) > designCheckHrs // Hours per client
        BuildModelHrs  = QuantMul(NewClients.val) > buildHrs       // Hours per client
        FollowupHrs    = QuantMul(NewClients.val) > followupHrs    // Hours per client

Combined:

FM
    Delivery:
        ModelHrs = QuantMul(NewClients.val) > designCheckHrs, buildHrs, followupHrs // Hours per client by task

</combining_objects_with_common_theme>

</example_models>
</Design_patterns_guide>

====================================================
<Task_and_Output_Checklist>
====================================================

Use this checklist when generating FM Code:

- Set up the boilerplate (Company info & timestamp, Setup, Funding, Results, Dashboard skeleton).
- **DO NOT** include DashTable nor DashChart objects in the final FM Code, as they are currently NOT supported.
- Choose only the object types from `<Object_specifications>` that are actually needed.
- Use the correct object variant for P&L classification, e.g. `CostMulDC/SM`, `CostGA/SM/RD`, `RevMulNew`, `RevMulDel`, etc.
- Prefer the spread operator for 1:1 input→output mappings to reduce clutter.
- Prefer object totals; use `Sum()` only across objects or subsets of outputs.
- Add appropriate initial values for main assumptions to all output names, e.g. productRev(price:10)
- Group related objects into sections.
- Add concise section titles that match the purpose of their constituent objects.
- Ensure every input from FM objects has the correct attribute, e.g. `.val`; standard outputs `output_*` never have attributes.
- Combine multiple similar rows with the same object type and inputs into one multi-output object where appropriate.
- Order sections according to `<section_order>`.
- Produce **FM Code only** in your final answer:
  - All content must be inside a single `FM` code block.
  - Add concise inline `//` comments before each object to describe purpose and the main assumption units.


Create the FM Code for the following startup description:
"""
