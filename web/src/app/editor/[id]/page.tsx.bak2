'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import { formatName } from '@/lib/formatters';
import { supabase } from '@/lib/supabaseClient';
import { useRouter } from 'next/navigation';
import { runEngine } from '@/lib/engine/engine';
import { buildOutputGraph } from '@/lib/engine/buildGraph';
import { buildModelAssumptions, updateAssumption, recalculateAll } from '@/lib/engine/buildModelAssumptions';
import { objectSchema } from '@/lib/engine/objectSchema';
import { fnRegistry } from '@/lib/engine/fnRegistry';
import { ObjectAssumptions } from '@/components/ObjectAssumptions';
import { ObjectOutputs } from '@/components/ObjectOutputs';

const SAMPLE_CODE = `
SetupAndFunding:
    Setup = Setup()
    EquityFunding = FundEquity() => startingCash
`;

export default function Editor({ params }: { params: { id: string } }) {
    const [code, setCode] = useState(SAMPLE_CODE);
    const [result, setResult] = useState<any>(null);
    const [engineResult, setEngineResult] = useState<any>(null);
    const [assumptions, setAssumptions] = useState<any>(null);
    const [overrides, setOverrides] = useState<any>({});
    const [error, setError] = useState<string | null>(null);
    const [saving, setSaving] = useState(false);
    const outputScrollRefs = useRef<(HTMLDivElement | null)[]>([]);
    const isScrolling = useRef(false);
    const [name, setName] = useState('Untitled Model');
    const [modelYears, setModelYears] = useState(2);
    const router = useRouter();

    // Helper to rehydrate Maps from JSON
    const rehydrateParseResult = (data: any) => {
        if (data.index) {
            if (data.index.outputsByObject && !(data.index.outputsByObject instanceof Map)) {
                data.index.outputsByObject = new Map(Object.entries(data.index.outputsByObject));
            }
            if (data.index.aliases && !(data.index.aliases instanceof Map)) {
                data.index.aliases = new Map(Object.entries(data.index.aliases));
            }
            if (data.index.objectsByName && !(data.index.objectsByName instanceof Map)) {
                data.index.objectsByName = new Map(Object.entries(data.index.objectsByName));
            }
        }
        return data;
    };

    // Check auth and load model
    useEffect(() => {
        const loadModel = async () => {
            const { data: { user } } = await supabase.auth.getUser();
            if (!user) {
                router.push('/login');
                return;
            }

            if (params.id !== 'new') {
                const { data, error } = await supabase
                    .from('models')
                    .select('*')
                    .eq('id', params.id)
                    .single();

                if (error) {
                    setError('Failed to load model: ' + error.message);
                } else if (data) {
                    setCode(data.fm_code || '');
                    setName(data.name || 'Untitled Model');

                    // We'll trigger a parse after setting code.
                    // But we need to handle the async nature.

                    // Let's fetch parse result here.
                    try {
                        const res = await fetch('/api/parse', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ fmCode: data.fm_code }),
                        });
                        const parseData = await res.json();
                        if (!res.ok) throw new Error(parseData.error || 'Failed to parse');

                        // Rehydrate Maps
                        const rehydrated = rehydrateParseResult(parseData);

                        setResult(rehydrated);

                        setOverrides(data.overrides || {});

                        // Load assumptions if they exist
                        if (data.assumptions) {
                            const restored = JSON.parse(JSON.stringify(data.assumptions), (key, value) => {
                                return value;
                            });

                            // Restore settings
                            if (restored._settings && restored._settings.modelYears) {
                                setModelYears(restored._settings.modelYears);
                            }

                            const restoreArrays = (obj: any) => {
                                if (!obj) return;
                                if (obj.value && Array.isArray(obj.value)) {
                                    obj.value = Float64Array.from(obj.value);
                                }
                                if (typeof obj === 'object') {
                                    for (const k in obj) {
                                        restoreArrays(obj[k]);
                                    }
                                }
                            };
                            restoreArrays(restored);
                            setAssumptions(restored);
                        }
                    } catch (e: any) {
                        console.error("Auto-parse on load failed", e);
                        setError("Failed to re-parse loaded model: " + e.message);
                    }
                }
            }
        };
        loadModel();
    }, [params.id, router]);

    // Initialize Assumptions when AST changes
    useEffect(() => {
        if (!result?.ast || !result?.index) return;

        setAssumptions((prev: any) => {
            const ctx = { months: modelYears * 12, years: modelYears };
            const defaults = buildModelAssumptions(result.ast, result.index, objectSchema, ctx);

            // If we have previous assumptions, try to merge them
            if (prev) {
                // Let's do a smart merge.
                const smartMerge = (def: any, existing: any) => {
                    if (!existing) return def;

                    // If both are objects
                    if (typeof def === 'object' && typeof existing === 'object') {
                        // If it's a field (has 'raw'), copy 'raw' and 'value'
                        if (def.raw !== undefined && existing.raw !== undefined) {
                            // Copy raw data
                            // IMPORTANT: Handle resizing of arrays if years changed
                            // But here we are merging existing (old) into defaults (new size)
                            // So we should take existing and fit into def

                            // Actually, let's just copy raw properties. 
                            // buildModelAssumptions logic should handle resizing if we implement it there?
                            // Or we do it here.
                            // Let's copy raw, but we might need to ensure arrays are long enough?
                            // For now, simple copy. We'll rely on buildModelAssumptions to have created correct size defaults,
                            // and we overlay existing data. If existing is shorter, we keep it short? No, we want new size.

                            // Better strategy: Copy scalar values. For arrays, copy elements.
                            const newRaw = { ...def.raw };
                            const oldRaw = existing.raw;

                            if (oldRaw.smoothing !== undefined) newRaw.smoothing = oldRaw.smoothing;
                            if (oldRaw.dateRange !== undefined) newRaw.dateRange = oldRaw.dateRange;

                            // Arrays: Copy what we have, keep new length (which is correct for current modelYears)
                            if (Array.isArray(newRaw.annual) && Array.isArray(oldRaw.annual)) {
                                const oldLen = oldRaw.annual.length;
                                const newLen = newRaw.annual.length;
                                const lastVal = oldLen > 0 ? oldRaw.annual[oldLen - 1] : null;

                                for (let i = 0; i < newLen; i++) {
                                    if (i < oldLen) {
                                        newRaw.annual[i] = oldRaw.annual[i];
                                    } else if (lastVal !== null) {
                                        // Extend with last value to avoid step changes
                                        newRaw.annual[i] = lastVal;
                                    }
                                }
                            }
                            if (Array.isArray(newRaw.growth) && Array.isArray(oldRaw.growth)) {
                                for (let i = 0; i < Math.min(newRaw.growth.length, oldRaw.growth.length); i++) {
                                    newRaw.growth[i] = oldRaw.growth[i];
                                }
                            }
                            // Monthly?
                            if (Array.isArray(newRaw.monthly) && Array.isArray(oldRaw.monthly)) {
                                for (let i = 0; i < Math.min(newRaw.monthly.length, oldRaw.monthly.length); i++) {
                                    newRaw.monthly[i] = oldRaw.monthly[i];
                                }
                            }
                            // Seasonal? (always 12 months)
                            if (Array.isArray(newRaw.seasonal) && Array.isArray(oldRaw.seasonal)) {
                                for (let i = 0; i < 12; i++) {
                                    if (i < oldRaw.seasonal.length) {
                                        newRaw.seasonal[i] = oldRaw.seasonal[i];
                                    }
                                }
                            }

                            def.raw = newRaw;

                            // Don't copy old value arrays - let buildModelAssumptions recalculate them
                            // from the raw data using the current/correct logic

                            return def;
                        }

                        for (const key in def) {
                            // Always use these keys from the new definition (schema), not from saved data
                            if (key === 'comment' || key === 'supports') continue;
                            if (existing[key] !== undefined) {
                                def[key] = smartMerge(def[key], existing[key]);
                            }
                        }
                        return def;
                    }
                    return existing;
                };

                // Create a deep copy of defaults to merge into
                const deepCopy = (obj: any): any => {
                    if (obj === null || typeof obj !== 'object') return obj;
                    if (obj instanceof Float64Array) return new Float64Array(obj);
                    if (Array.isArray(obj)) return obj.map(deepCopy);
                    const copy: { [key: string]: any } = {};
                    for (const key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) {
                            copy[key] = deepCopy(obj[key]);
                        }
                    }
                    return copy;
                };

                const mergedDefaults = deepCopy(defaults);
                const merged = smartMerge(mergedDefaults, prev);
                return recalculateAll(merged, ctx);
            }

            return defaults;
        });
    }, [result, modelYears]); // Re-run when modelYears changes

    // Run Engine on Client
    const runClientEngine = useCallback(() => {
        if (!result?.ast || !result?.index || !assumptions) return;

        try {
            console.log("Running engine with assumptions:", assumptions);
            const graph = buildOutputGraph(result.ast, result.index);
            const ctx = { months: modelYears * 12, years: modelYears };

            const engineOutput = runEngine({
                ast: result.ast,
                index: result.index,
                outGraph: graph,
                assumptions,
                ctx,
                fnRegistry,
                objectSchema,
                overrides
            });

            console.log("Engine output:", engineOutput);
            setEngineResult(engineOutput);
        } catch (e: any) {
            console.error("Engine error:", e);
            setError("Engine Error: " + e.message);
        }
    }, [result, assumptions, overrides, modelYears]);

    // Debounce engine run? For now, just run on effect
    useEffect(() => {
        runClientEngine();
    }, [runClientEngine]);

    const handleParse = async () => {
        setError(null);
        try {
            const res = await fetch('/api/parse', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ fmCode: code }),
            });
            const data = await res.json();
            if (!res.ok) throw new Error(data.error || 'Failed to parse');

            const rehydrated = rehydrateParseResult(data);

            // Validate that we can build assumptions from this result
            try {
                const testCtx = { months: modelYears * 12, years: modelYears };
                buildModelAssumptions(rehydrated.ast, rehydrated.index, objectSchema, testCtx);
            } catch (e: any) {
                throw new Error("Error building assumptions: " + e.message);
            }

            setResult(rehydrated);
        } catch (err: any) {
            setError(err.message);
        }
    };

    const handleSave = async () => {
        setSaving(true);
        try {
            const { data: { user } } = await supabase.auth.getUser();
            if (!user) throw new Error('Not authenticated');

            // Serialize assumptions: Convert Float64Array to Array
            const serializableAssumptions = JSON.parse(JSON.stringify(assumptions, (key, value) => {
                if (value && value.constructor === Float64Array) {
                    return Array.from(value);
                }
                return value;
            }));

            // Save settings inside assumptions
            serializableAssumptions._settings = { modelYears };

            const modelData = {
                user_id: user.id,
                name: name,
                fm_code: code,
                ast: result?.ast,
                assumptions: serializableAssumptions,
                overrides: overrides
            };

            if (params.id === 'new') {
                const { data, error } = await supabase
                    .from('models')
                    .insert([modelData])
                    .select()
                    .single();
                if (error) throw error;
                router.push(`/editor/${data.id}`);
            } else {
                const { error } = await supabase
                    .from('models')
                    .update(modelData)
                    .eq('id', params.id);
                if (error) throw error;
            }
        } catch (err: any) {
            setError(err.message);
        } finally {
            setSaving(false);
        }
    };

    const handleAssumptionChange = (objName: string, type: 'object' | 'output' | 'meta', aliasOrName: string, fieldName: string, value: any, subField?: string | null, index?: number | null) => {
        try {
            if (!assumptions) return;
            const ctx = { months: modelYears * 12, years: modelYears };
            const newAssumptions = updateAssumption(assumptions, objName, type, aliasOrName, fieldName, value, ctx, subField ?? null, index ?? null);
            setAssumptions(newAssumptions);
        } catch (e) {
            console.error("Error updating assumption:", e);
            setError("Error updating assumption: " + (e as any).message);
        }
    };

    const handleOverride = (alias: string, channel: string, month: number, value: number | null) => {
        setOverrides((prev: any) => {
            const newOverrides = { ...prev };
            if (!newOverrides[alias]) newOverrides[alias] = {};
            if (!newOverrides[alias][channel]) newOverrides[alias][channel] = {};

            if (value === null) {
                delete newOverrides[alias][channel][month];
                // Cleanup empty objects if needed, but not strictly necessary
            } else {
                newOverrides[alias][channel][month] = value;
            }
            return newOverrides;
        });
    };

    // Calculate dynamic column spans based on years
    // We must use full class strings for Tailwind to detect them
    let leftColClass = "lg:col-span-4";
    let rightColClass = "lg:col-span-8";

    if (modelYears > 3) {
        leftColClass = "lg:col-span-5";
        rightColClass = "lg:col-span-7";
    }
    if (modelYears > 6) {
        leftColClass = "lg:col-span-6";
        rightColClass = "lg:col-span-6";
    }

    return (
        <main className="flex min-h-screen flex-col items-center p-4 bg-gray-50 text-black">
            <div className="w-full max-w-[1600px] flex justify-between items-center mb-4">
                <div className="flex items-center gap-4">
                    <button
                        onClick={() => router.push('/dashboard')}
                        className="text-gray-500 hover:text-gray-700 font-bold text-xl"
                    >
                        &larr;
                    </button>
                    <input
                        type="text"
                        value={name}
                        onChange={(e) => setName(e.target.value)}
                        className="text-2xl font-bold text-blue-800 bg-transparent border-b-2 border-transparent hover:border-blue-200 focus:border-blue-500 focus:outline-none transition-colors"
                    />
                </div>
                <div className="flex gap-4 items-center">
                    {/* Model Years Control */}
                    <div className="flex items-center gap-2 bg-white px-3 py-1.5 rounded border border-gray-200 shadow-sm">
                        <label className="text-xs font-medium text-gray-500 uppercase">Years</label>
                        <input
                            type="number"
                            min="1"
                            max="10"
                            value={modelYears}
                            onChange={(e) => setModelYears(Math.max(1, Math.min(10, parseInt(e.target.value) || 1)))}
                            className="w-12 text-center font-bold text-gray-700 outline-none border-b border-transparent focus:border-blue-500"
                        />
                    </div>

                    {error && <div className="text-red-600 text-sm">{error}</div>}
                    <button
                        onClick={handleSave}
                        disabled={saving}
                        className="px-4 py-2 bg-green-600 text-white font-semibold rounded hover:bg-green-700 transition-colors shadow-sm disabled:opacity-50 text-sm"
                    >
                        {saving ? 'Saving...' : 'Save'}
                    </button>
                </div>
            </div>

            <div className="w-full max-w-[1600px] mb-4">
                <details className="mb-4 bg-white rounded border border-gray-200">
                    <summary className="p-2 cursor-pointer font-medium text-gray-600 hover:bg-gray-50">FM Code Editor</summary>
                    <div className="p-4 flex flex-col gap-2">
                        <textarea
                            className="w-full h-40 p-4 font-mono text-sm border rounded shadow-sm focus:ring-2 focus:ring-blue-500 outline-none resize-y"
                            value={code}
                            onChange={(e) => setCode(e.target.value)}
                            spellCheck={false}
                        />
                        <button
                            onClick={handleParse}
                            className="self-start px-4 py-2 bg-blue-600 text-white font-semibold rounded hover:bg-blue-700 transition-colors shadow-sm text-sm"
                        >
                            Parse & Build Graph
                        </button>
                    </div>
                </details>
            </div>

            <div className="w-full max-w-[1600px] flex flex-col gap-4 pb-20">
                {result?.ast?.objects && assumptions ? (
                    result.ast.objects.map((obj: any, index: number) => {
                        const objName = obj.name;
                        const aliases = result.index.outputsByObject.get(objName) || [];
                        const typeName = obj.fnName;
                        const channelDefs = typeName ? (objectSchema as any)[typeName]?.channels : {};

                        const prevObj = index > 0 ? result.ast.objects[index - 1] : null;
                        const showSection = obj.section && (!prevObj || obj.section !== prevObj.section);

                        return (
                            <div key={objName} className="flex flex-col">
                                {(!assumptions[objName]) ? null : (
                                    <>
                                        {showSection && (
                                            <div className="w-full border-b-2 border-gray-200 mb-6 mt-4 pb-2">
                                                <h2 className="text-2xl font-bold text-gray-800">{formatName(obj.section)}</h2>
                                            </div>
                                        )}
                                        <div className="grid grid-cols-1 lg:grid-cols-12 gap-3 border-b border-gray-200 pb-4">
                                            <div className={leftColClass}>
                                                <ObjectAssumptions
                                                    objName={objName}
                                                    objAss={assumptions[objName]}
                                                    years={modelYears}
                                                    uiMode={assumptions[objName].uiMode as 'single' | 'annual' | 'growth'}
                                                    onChange={handleAssumptionChange}
                                                />
                                            </div>
                                            <div
                                                ref={(el) => { outputScrollRefs.current[index] = el; }}
                                                className={`${rightColClass} overflow-x-auto`}
                                                onScroll={(e) => {
                                                    if (isScrolling.current) return;
                                                    isScrolling.current = true;
                                                    const scrollLeft = e.currentTarget.scrollLeft;
                                                    outputScrollRefs.current.forEach((ref, i) => {
                                                        if (ref && i !== index) {
                                                            ref.scrollLeft = scrollLeft;
                                                        }
                                                    });
                                                    requestAnimationFrame(() => {
                                                        isScrolling.current = false;
                                                    });
                                                }}
                                            >
                                                <ObjectOutputs
                                                    aliases={aliases}
                                                    store={engineResult?.store}
                                                    overrides={overrides}
                                                    months={modelYears * 12}
                                                    channelDefs={channelDefs}
                                                    onOverride={handleOverride}
                                                    objAss={assumptions[objName]}
                                                    seasonalEnabled={assumptions[objName]?.seasonalEnabled ?? false}
                                                    objName={objName}
                                                    onAssumptionChange={handleAssumptionChange}
                                                />
                                            </div>
                                        </div>
                                    </>
                                )}
                            </div>
                        );
                    })
                ) : (
                    <div className="text-center text-gray-500 py-10">
                        {result ? "Loading assumptions..." : "Parse the model to see assumptions and outputs."}
                    </div>
                )}
            </div>
        </main>
    );
}
